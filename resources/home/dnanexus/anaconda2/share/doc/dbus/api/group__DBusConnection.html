<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>D-Bus: DBusConnection</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>DBusConnection<br>
<small>
[<a class="el" href="group__DBus.html">D-Bus low-level public API</a>]</small>
</h1>Connection to another application.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual table that must be implemented to handle a portion of the object path hierarchy.  <a href="structDBusObjectPathVTable.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gadc8a802cfffb0719d394609d9cd2186"></a><!-- doxytag: member="DBusConnection::DBusPreallocatedSend" ref="gadc8a802cfffb0719d394609d9cd2186" args="" -->
typedef <a class="el" href="structDBusPreallocatedSend.html">DBusPreallocatedSend</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gadc8a802cfffb0719d394609d9cd2186">DBusPreallocatedSend</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque type representing preallocated resources so a message can be sent without further memory allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g168c25556d88c296ebc64f1d7b20f699"></a><!-- doxytag: member="DBusConnection::DBusConnection" ref="g168c25556d88c296ebc64f1d7b20f699" args="" -->
typedef <a class="el" href="structDBusConnection.html">DBusConnection</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g168c25556d88c296ebc64f1d7b20f699">DBusConnection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque type representing a connection to a remote application and associated incoming/outgoing message queues. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4dd10016d1f17d1a2fbf0ad913c90427"></a><!-- doxytag: member="DBusConnection::DBusObjectPathVTable" ref="g4dd10016d1f17d1a2fbf0ad913c90427" args="" -->
typedef <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g4dd10016d1f17d1a2fbf0ad913c90427">DBusObjectPathVTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set of functions that must be implemented to handle messages sent to a particular object path. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g985b712fc165afa66e5901859b68b9de">DBusAddWatchFunction</a> (<a class="el" href="structDBusWatch.html">DBusWatch</a> *watch, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when libdbus needs a new watch to be monitored by the main loop.  <a href="#g985b712fc165afa66e5901859b68b9de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gfa7e0f7856f8ebbe66475979ef54ed9e">DBusWatchToggledFunction</a> (<a class="el" href="structDBusWatch.html">DBusWatch</a> *watch, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when <a class="el" href="group__DBusWatch.html#ge7a91e6d4d1bc187419c47c522e33a8f">dbus_watch_get_enabled()</a> may return a different value than it did before.  <a href="#gfa7e0f7856f8ebbe66475979ef54ed9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g6a48c42c4bde24911cae7fda0d1f1589">DBusRemoveWatchFunction</a> (<a class="el" href="structDBusWatch.html">DBusWatch</a> *watch, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when libdbus no longer needs a watch to be monitored by the main loop.  <a href="#g6a48c42c4bde24911cae7fda0d1f1589"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g0f4e9f850546dfbe3a27edea05e5e590">DBusAddTimeoutFunction</a> (<a class="el" href="structDBusTimeout.html">DBusTimeout</a> *timeout, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when libdbus needs a new timeout to be monitored by the main loop.  <a href="#g0f4e9f850546dfbe3a27edea05e5e590"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g1e98eb88ce848204d419495be5e1d228">DBusTimeoutToggledFunction</a> (<a class="el" href="structDBusTimeout.html">DBusTimeout</a> *timeout, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when <a class="el" href="group__DBusTimeout.html#g58954b2edb45ec1632529d35525ea45c">dbus_timeout_get_enabled()</a> may return a different value than it did before.  <a href="#g1e98eb88ce848204d419495be5e1d228"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gb11e8c56bd8637deca1439be635f6ca7">DBusRemoveTimeoutFunction</a> (<a class="el" href="structDBusTimeout.html">DBusTimeout</a> *timeout, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when libdbus no longer needs a timeout to be monitored by the main loop.  <a href="#gb11e8c56bd8637deca1439be635f6ca7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gd888331dd2737769f669c5df779fe0ef">DBusDispatchStatusFunction</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a> new_status, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the return value of <a class="el" href="group__DBusConnection.html#g893d18d8b36ffb371f16d13645071289">dbus_connection_get_dispatch_status()</a> may have changed.  <a href="#gd888331dd2737769f669c5df779fe0ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g8d21e6bab0bbca3efd2c6d5acb53d468">DBusWakeupMainFunction</a> (void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the main loop's thread should be notified that there's now work to do.  <a href="#g8d21e6bab0bbca3efd2c6d5acb53d468"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g141b80629859a4c154c793f08c33d687">DBusAllowUnixUserFunction</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, unsigned long uid, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called during authentication to check whether the given UNIX user ID is allowed to connect, if the client tried to auth as a UNIX user ID.  <a href="#g141b80629859a4c154c793f08c33d687"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gf5c1e751b33a480c33f9141ad3ac75d9">DBusAllowWindowsUserFunction</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *user_sid, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called during authentication to check whether the given Windows user ID is allowed to connect, if the client tried to auth as a Windows user ID.  <a href="#gf5c1e751b33a480c33f9141ad3ac75d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g7a3483add4000e5498cd46f64d2b7c9a">DBusPendingCallNotifyFunction</a> (<a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> *pending, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a pending call now has a reply available.  <a href="#g7a3483add4000e5498cd46f64d2b7c9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__DBusShared.html#g8244b29230187624c24986c24edab1de">DBusHandlerResult</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g5cbcefc9b79af6e468eba14d0d7197b2">DBusHandleMessageFunction</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a message needs to be handled.  <a href="#g5cbcefc9b79af6e468eba14d0d7197b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gd0fc0a7c19169605633760b2bbe5e3e0">DBusObjectPathUnregisterFunction</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> is unregistered (or its connection is freed).  <a href="#gd0fc0a7c19169605633760b2bbe5e3e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__DBusShared.html#g8244b29230187624c24986c24edab1de">DBusHandlerResult</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g55257eacf7f9f98b1302e6dcc96c6dd4">DBusObjectPathMessageFunction</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a message is sent to a registered object path.  <a href="#g55257eacf7f9f98b1302e6dcc96c6dd4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g0556779e61aeb19eb9cf6b6466bd1b98">DBusWatchFlags</a> { <a class="el" href="group__DBusConnection.html#gg0556779e61aeb19eb9cf6b6466bd1b98178bd7a88e9bfbb8505db76eb7e0ccc4">DBUS_WATCH_READABLE</a> =  1 &lt;&lt; 0, 
<a class="el" href="group__DBusConnection.html#gg0556779e61aeb19eb9cf6b6466bd1b9862ddca29b06bfbbc08bb7f3dfd3d307f">DBUS_WATCH_WRITABLE</a> =  1 &lt;&lt; 1, 
<a class="el" href="group__DBusConnection.html#gg0556779e61aeb19eb9cf6b6466bd1b98b1474e26aa5be3d2876dd86bbe452156">DBUS_WATCH_ERROR</a> =  1 &lt;&lt; 2, 
<a class="el" href="group__DBusConnection.html#gg0556779e61aeb19eb9cf6b6466bd1b987a361a1a03f463c3c9e57f7368a0bfe4">DBUS_WATCH_HANGUP</a> =  1 &lt;&lt; 3
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates the status of a <a class="el" href="structDBusWatch.html">DBusWatch</a>.  <a href="group__DBusConnection.html#g0556779e61aeb19eb9cf6b6466bd1b98">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a> { <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a>, 
<a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2cb9bb9daa90f520d5fc9e84de3c5f017">DBUS_DISPATCH_COMPLETE</a>, 
<a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d25af20a035f29cfa67fb8d69fb693b685">DBUS_DISPATCH_NEED_MEMORY</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates the status of incoming data on a <a class="el" href="structDBusConnection.html">DBusConnection</a>.  <a href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open</a> (const char *address, <a class="el" href="structDBusError.html">DBusError</a> *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a connection to a remote address.  <a href="#gcd32f819820266598c6b6847dfddaf9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g434e3fc7ee420fd30e2f05e57ff26b1d">dbus_connection_open_private</a> (const char *address, <a class="el" href="structDBusError.html">DBusError</a> *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a new, dedicated connection to a remote address.  <a href="#g434e3fc7ee420fd30e2f05e57ff26b1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#ge34751e15f114217e5ad10c663e2ef2e">dbus_connection_ref</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increments the reference count of a <a class="el" href="structDBusConnection.html">DBusConnection</a>.  <a href="#ge34751e15f114217e5ad10c663e2ef2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g6385ff09bc108238c4429e7c195dab25">dbus_connection_unref</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrements the reference count of a <a class="el" href="structDBusConnection.html">DBusConnection</a>, and finalizes it if the count reaches zero.  <a href="#g6385ff09bc108238c4429e7c195dab25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g2522ac5075dfe0a1535471f6e045e1ee">dbus_connection_close</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a private connection, so no further data can be sent or received.  <a href="#g2522ac5075dfe0a1535471f6e045e1ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g611ae94556af36fe30bfb547366ca4e1">dbus_connection_get_is_connected</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether the connection is currently open.  <a href="#g611ae94556af36fe30bfb547366ca4e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g2f1fa02c9897b6f07f4d33c862de4a1d">dbus_connection_get_is_authenticated</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether the connection was authenticated.  <a href="#g2f1fa02c9897b6f07f4d33c862de4a1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#ga6c5d523e16d8a5b9316c92d9ff1ac17">dbus_connection_get_is_anonymous</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether the connection is not authenticated as a specific user.  <a href="#ga6c5d523e16d8a5b9316c92d9ff1ac17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#ge6c19e146a37f9de6a06c1617874bed9">dbus_connection_get_server_id</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the ID of the server address we are authenticated to, if this connection is on the client side.  <a href="#ge6c19e146a37f9de6a06c1617874bed9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g3e41509b3afdbc22872bacc5754e85c2">dbus_connection_can_send_type</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests whether a certain type can be send via the connection.  <a href="#g3e41509b3afdbc22872bacc5754e85c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g19091beb74f1504b0e862a7ad10e71cd">dbus_connection_set_exit_on_disconnect</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> exit_on_disconnect)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether _exit() should be called when the connection receives a disconnect signal.  <a href="#g19091beb74f1504b0e862a7ad10e71cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDBusPreallocatedSend.html">DBusPreallocatedSend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g6136968eba30e8313e668a622fcfb08d">dbus_connection_preallocate_send</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.  <a href="#g6136968eba30e8313e668a622fcfb08d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gd0ea06307b418616711131ea7bdae8ac">dbus_connection_free_preallocated_send</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusPreallocatedSend.html">DBusPreallocatedSend</a> *preallocated)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees preallocated message-sending resources from <a class="el" href="group__DBusConnection.html#g6136968eba30e8313e668a622fcfb08d">dbus_connection_preallocate_send()</a>.  <a href="#gd0ea06307b418616711131ea7bdae8ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g2fea5f972d1bfe7bcde8c0ec65ca9e90">dbus_connection_send_preallocated</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusPreallocatedSend.html">DBusPreallocatedSend</a> *preallocated, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *client_serial)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a message using preallocated resources.  <a href="#g2fea5f972d1bfe7bcde8c0ec65ca9e90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#ge1cb64f4cf550949b23fd3a756b2f7d0">dbus_connection_send</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *serial)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a message to the outgoing message queue.  <a href="#ge1cb64f4cf550949b23fd3a756b2f7d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#ga215df7ab7ca6dce7be153c6b9cc80ba">dbus_connection_send_with_reply</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> **pending_return, int timeout_milliseconds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queues a message to send, as with <a class="el" href="group__DBusConnection.html#ge1cb64f4cf550949b23fd3a756b2f7d0">dbus_connection_send()</a>, but also returns a <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> used to receive a reply to the message.  <a href="#ga215df7ab7ca6dce7be153c6b9cc80ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g8d6431f17a9e53c9446d87c2ba8409f0">dbus_connection_send_with_reply_and_block</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, int timeout_milliseconds, <a class="el" href="structDBusError.html">DBusError</a> *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a message and blocks a certain time period while waiting for a reply.  <a href="#g8d6431f17a9e53c9446d87c2ba8409f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g10e68d9d2f41d655a4151ddeb807ff54">dbus_connection_flush</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blocks until the outgoing message queue is empty.  <a href="#g10e68d9d2f41d655a4151ddeb807ff54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g580d8766c23fe5f49418bc7d87b67dc6">dbus_connection_read_write_dispatch</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, int timeout_milliseconds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is intended for use with applications that don't want to write a main loop and deal with <a class="el" href="structDBusWatch.html">DBusWatch</a> and <a class="el" href="structDBusTimeout.html">DBusTimeout</a>.  <a href="#g580d8766c23fe5f49418bc7d87b67dc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g371163b4955a6e0bf0f1f70f38390c14">dbus_connection_read_write</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, int timeout_milliseconds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is intended for use with applications that don't want to write a main loop and deal with <a class="el" href="structDBusWatch.html">DBusWatch</a> and <a class="el" href="structDBusTimeout.html">DBusTimeout</a>.  <a href="#g371163b4955a6e0bf0f1f70f38390c14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first-received message from the incoming message queue, leaving it in the queue.  <a href="#g9d07083c520e291591a68adb78f64094"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g0586da03a01c9c6f332fbea900ef55e3">dbus_connection_return_message</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to return a message after peeking at it using <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a>.  <a href="#g0586da03a01c9c6f332fbea900ef55e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g7125d747575b2f596aceaf7be53eae68">dbus_connection_steal_borrowed_message</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to keep a message after peeking at it using <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a>.  <a href="#g7125d747575b2f596aceaf7be53eae68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g1e40d994ea162ce767e78de1c4988566">dbus_connection_pop_message</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first-received message from the incoming message queue, removing it from the queue.  <a href="#g1e40d994ea162ce767e78de1c4988566"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g893d18d8b36ffb371f16d13645071289">dbus_connection_get_dispatch_status</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current state of the incoming message queue.  <a href="#g893d18d8b36ffb371f16d13645071289"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes any incoming data.  <a href="#g66ba7df50d75f4bda6b6e942430b81c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#g985b712fc165afa66e5901859b68b9de">DBusAddWatchFunction</a> add_function, <a class="el" href="group__DBusConnection.html#g6a48c42c4bde24911cae7fda0d1f1589">DBusRemoveWatchFunction</a> remove_function, <a class="el" href="group__DBusConnection.html#gfa7e0f7856f8ebbe66475979ef54ed9e">DBusWatchToggledFunction</a> toggled_function, void *data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the watch functions for the connection.  <a href="#gebf031eb444b4f847606aa27daa3d8e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gb3cbc68eec427e9ce1783b25d44fe93c">dbus_connection_set_timeout_functions</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#g0f4e9f850546dfbe3a27edea05e5e590">DBusAddTimeoutFunction</a> add_function, <a class="el" href="group__DBusConnection.html#gb11e8c56bd8637deca1439be635f6ca7">DBusRemoveTimeoutFunction</a> remove_function, <a class="el" href="group__DBusConnection.html#g1e98eb88ce848204d419495be5e1d228">DBusTimeoutToggledFunction</a> toggled_function, void *data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the timeout functions for the connection.  <a href="#gb3cbc68eec427e9ce1783b25d44fe93c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g2b1df13251c7ec348bcba39c0924e881">dbus_connection_set_wakeup_main_function</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#g8d21e6bab0bbca3efd2c6d5acb53d468">DBusWakeupMainFunction</a> wakeup_main_function, void *data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mainloop wakeup function for the connection.  <a href="#g2b1df13251c7ec348bcba39c0924e881"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g55ff88cd22c0672441c7deffbfb68fbf">dbus_connection_set_dispatch_status_function</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#gd888331dd2737769f669c5df779fe0ef">DBusDispatchStatusFunction</a> function, void *data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a function to be invoked when the dispatch status changes.  <a href="#g55ff88cd22c0672441c7deffbfb68fbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g38297f511f4124accdfa68c321e081cc">dbus_connection_get_unix_fd</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, int *fd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the UNIX file descriptor of the connection, if any.  <a href="#g38297f511f4124accdfa68c321e081cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g1c14590d77b148390bde9e82a7544434">dbus_connection_get_socket</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, int *fd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the underlying Windows or UNIX socket file descriptor of the connection, if any.  <a href="#g1c14590d77b148390bde9e82a7544434"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gef670c3a8170ab9c719ec955252459d0">dbus_connection_get_unix_user</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, unsigned long *uid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the UNIX user ID of the connection if known.  <a href="#gef670c3a8170ab9c719ec955252459d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#geebeadcafa87e2d30eed4296f26fb73c">dbus_connection_get_unix_process_id</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, unsigned long *pid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the process ID of the connection if any.  <a href="#geebeadcafa87e2d30eed4296f26fb73c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g969b9dafe806c9fe0a54c9d8a565c2e1">dbus_connection_get_adt_audit_session_data</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, void **data, <a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> *data_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the ADT audit data of the connection if any.  <a href="#g969b9dafe806c9fe0a54c9d8a565c2e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g6b78379badb4c5804344f4f3d87a958a">dbus_connection_set_unix_user_function</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#g141b80629859a4c154c793f08c33d687">DBusAllowUnixUserFunction</a> function, void *data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a predicate function used to determine whether a given user ID is allowed to connect.  <a href="#g6b78379badb4c5804344f4f3d87a958a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g06378d6ee9a213cea45965288338966a"></a><!-- doxytag: member="DBusConnection::_dbus_connection_get_linux_security_label" ref="g06378d6ee9a213cea45965288338966a" args="(DBusConnection *connection, char **label_p)" -->
<a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g06378d6ee9a213cea45965288338966a">_dbus_connection_get_linux_security_label</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, char **label_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g2b3cb488f1922aeecdeafdcb110e91a8">dbus_connection_get_windows_user</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, char **windows_sid_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the Windows user SID of the connection if known.  <a href="#g2b3cb488f1922aeecdeafdcb110e91a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#ga35ced9ccd29d3366749ae383b120f9c">dbus_connection_set_windows_user_function</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#gf5c1e751b33a480c33f9141ad3ac75d9">DBusAllowWindowsUserFunction</a> function, void *data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a predicate function used to determine whether a given user ID is allowed to connect.  <a href="#ga35ced9ccd29d3366749ae383b120f9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gde349ff04ed548993a8054250e317c12">dbus_connection_set_allow_anonymous</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function must be called on the server side of a connection when the connection is first seen in the <a class="el" href="group__DBusServer.html#g86c64a45e0834df26a8feae3079f6fbf">DBusNewConnectionFunction</a>.  <a href="#gde349ff04ed548993a8054250e317c12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gf58e8cc7b8717db1581459c0c3d34b08">dbus_connection_set_route_peer_messages</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normally <a class="el" href="structDBusConnection.html">DBusConnection</a> automatically handles all messages to the org.freedesktop.DBus.Peer interface.  <a href="#gf58e8cc7b8717db1581459c0c3d34b08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#ge00f581e5487408cb294bf71826aff86">dbus_connection_add_filter</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#g5cbcefc9b79af6e468eba14d0d7197b2">DBusHandleMessageFunction</a> function, void *user_data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a message filter.  <a href="#ge00f581e5487408cb294bf71826aff86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g5e7f1dad410506a8a6f5182c55e7c4fe">dbus_connection_remove_filter</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#g5cbcefc9b79af6e468eba14d0d7197b2">DBusHandleMessageFunction</a> function, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a previously-added message filter.  <a href="#g5e7f1dad410506a8a6f5182c55e7c4fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g708b1e108feed18f5775ff404c9dda4b">dbus_connection_try_register_object_path</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *path, const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *vtable, void *user_data, <a class="el" href="structDBusError.html">DBusError</a> *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a handler for a given path in the object hierarchy.  <a href="#g708b1e108feed18f5775ff404c9dda4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g24730ca6fd2e9132873962a32df7628c">dbus_connection_register_object_path</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *path, const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *vtable, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a handler for a given path in the object hierarchy.  <a href="#g24730ca6fd2e9132873962a32df7628c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g8e9d2d4ff17c3071124e4993d1536ed4">dbus_connection_try_register_fallback</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *path, const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *vtable, void *user_data, <a class="el" href="structDBusError.html">DBusError</a> *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a fallback handler for a given subsection of the object hierarchy.  <a href="#g8e9d2d4ff17c3071124e4993d1536ed4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gc4473b37bfa74ccf7459959d27e7bc59">dbus_connection_register_fallback</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *path, const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *vtable, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a fallback handler for a given subsection of the object hierarchy.  <a href="#gc4473b37bfa74ccf7459959d27e7bc59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g6ae8f005dedf24c5f2df1768795392fb">dbus_connection_unregister_object_path</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters the handler registered with exactly the given path.  <a href="#g6ae8f005dedf24c5f2df1768795392fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g08ee6e70b74c294fe24d0f391f16db24">dbus_connection_get_object_path_data</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *path, void **data_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the user data passed to <a class="el" href="group__DBusConnection.html#g24730ca6fd2e9132873962a32df7628c">dbus_connection_register_object_path()</a> or <a class="el" href="group__DBusConnection.html#gc4473b37bfa74ccf7459959d27e7bc59">dbus_connection_register_fallback()</a>.  <a href="#g08ee6e70b74c294fe24d0f391f16db24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g3e9de2067d0eed66ef73230fae8d8be2">dbus_connection_list_registered</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *parent_path, char ***child_entries)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lists the registered fallback handlers and object path handlers at the given parent_path.  <a href="#g3e9de2067d0eed66ef73230fae8d8be2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g728b15c71a492ad244e5a480f1156088">dbus_connection_allocate_data_slot</a> (<a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> *slot_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates an integer ID to be used for storing application-specific data on any <a class="el" href="structDBusConnection.html">DBusConnection</a>.  <a href="#g728b15c71a492ad244e5a480f1156088"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g7dc8c73d8c3e733f5410d52be84239a0">dbus_connection_free_data_slot</a> (<a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> *slot_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates a global ID for connection data slots.  <a href="#g7dc8c73d8c3e733f5410d52be84239a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g845b4942399f43dd4ac644de7cb9e3ff">dbus_connection_set_data</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> slot, void *data, <a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a> free_data_func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores a pointer on a <a class="el" href="structDBusConnection.html">DBusConnection</a>, along with an optional function to be used for freeing the data when the data is set again, or when the connection is finalized.  <a href="#g845b4942399f43dd4ac644de7cb9e3ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g433fae9844a66d9d078d238e6c723b95">dbus_connection_get_data</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> slot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves data previously set with <a class="el" href="group__DBusConnection.html#g845b4942399f43dd4ac644de7cb9e3ff">dbus_connection_set_data()</a>.  <a href="#g433fae9844a66d9d078d238e6c723b95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g794d0b572e30448fb262618222f76124">dbus_connection_set_change_sigpipe</a> (<a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> will_modify_sigpipe)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets a global flag for whether dbus_connection_new() will set SIGPIPE behavior to SIG_IGN.  <a href="#g794d0b572e30448fb262618222f76124"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g0d783462274a6c71d3767f5821c29ce9">dbus_connection_set_max_message_size</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, long size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the maximum size message this connection is allowed to receive.  <a href="#g0d783462274a6c71d3767f5821c29ce9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g7a459e64d7dca7b592136cec0a73422c">dbus_connection_get_max_message_size</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value set by <a class="el" href="group__DBusConnection.html#g0d783462274a6c71d3767f5821c29ce9">dbus_connection_set_max_message_size()</a>.  <a href="#g7a459e64d7dca7b592136cec0a73422c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g2aadce7d15c0e11983363912292b3fcd">dbus_connection_set_max_message_unix_fds</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the maximum number of unix fds a message on this connection is allowed to receive.  <a href="#g2aadce7d15c0e11983363912292b3fcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g18abaca9a512dbb7b6f921c3df6875d9">dbus_connection_get_max_message_unix_fds</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value set by <a class="el" href="group__DBusConnection.html#g2aadce7d15c0e11983363912292b3fcd">dbus_connection_set_max_message_unix_fds()</a>.  <a href="#g18abaca9a512dbb7b6f921c3df6875d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g6565d75f16e6e803372b2ae3d94d991b">dbus_connection_set_max_received_size</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, long size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum total number of bytes that can be used for all messages received on this connection.  <a href="#g6565d75f16e6e803372b2ae3d94d991b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g376529acf41d1d34b4f46c0d9d515c85">dbus_connection_get_max_received_size</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value set by <a class="el" href="group__DBusConnection.html#g6565d75f16e6e803372b2ae3d94d991b">dbus_connection_set_max_received_size()</a>.  <a href="#g376529acf41d1d34b4f46c0d9d515c85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g81e63dc6d9298e8a7f92c0d93d0e80b3">dbus_connection_set_max_received_unix_fds</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum total number of unix fds that can be used for all messages received on this connection.  <a href="#g81e63dc6d9298e8a7f92c0d93d0e80b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g219f31132338616f82dc975c070ff418">dbus_connection_get_max_received_unix_fds</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value set by <a class="el" href="group__DBusConnection.html#g81e63dc6d9298e8a7f92c0d93d0e80b3">dbus_connection_set_max_received_unix_fds()</a>.  <a href="#g219f31132338616f82dc975c070ff418"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g47aff801f586e7116f9c54532bb1baf9">dbus_connection_get_outgoing_size</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the approximate size in bytes of all messages in the outgoing message queue.  <a href="#g47aff801f586e7116f9c54532bb1baf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8c022a21b890c6956094819709fcc266"></a><!-- doxytag: member="DBusConnection::_dbus_connection_get_stats" ref="g8c022a21b890c6956094819709fcc266" args="(DBusConnection *connection, dbus_uint32_t *in_messages, dbus_uint32_t *in_bytes, dbus_uint32_t *in_fds, dbus_uint32_t *in_peak_bytes, dbus_uint32_t *in_peak_fds, dbus_uint32_t *out_messages, dbus_uint32_t *out_bytes, dbus_uint32_t *out_fds, dbus_uint32_t *out_peak_bytes, dbus_uint32_t *out_peak_fds)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#g8c022a21b890c6956094819709fcc266">_dbus_connection_get_stats</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *in_messages, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *in_bytes, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *in_fds, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *in_peak_bytes, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *in_peak_fds, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *out_messages, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *out_bytes, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *out_fds, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *out_peak_bytes, <a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *out_peak_fds)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gd218838fdaa8d36c606723c63e96f453">dbus_connection_get_outgoing_unix_fds</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the approximate number of uni fds of all messages in the outgoing message queue.  <a href="#gd218838fdaa8d36c606723c63e96f453"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DBusConnection.html#gc40563ec4c0e309d936daf3163ba9bb7">dbus_connection_has_messages_to_send</a> (<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether there are messages in the outgoing message queue.  <a href="#gc40563ec4c0e309d936daf3163ba9bb7"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Connection to another application. 
<p>
A <a class="el" href="structDBusConnection.html">DBusConnection</a> represents a connection to another application. Messages can be sent and received via this connection. The other application may be a message bus; for convenience, the function <a class="el" href="group__DBusBus.html#g77ba5250adb84620f16007e1b023cf26">dbus_bus_get()</a> is provided to automatically open a connection to the well-known message buses.<p>
In brief a <a class="el" href="structDBusConnection.html">DBusConnection</a> is a message queue associated with some message transport mechanism such as a socket. The connection maintains a queue of incoming messages and a queue of outgoing messages.<p>
Several functions use the following terms: <ul>
<li>
<b>read</b> means to fill the incoming message queue by reading from the socket </li>
<li>
<b>write</b> means to drain the outgoing queue by writing to the socket </li>
<li>
<b>dispatch</b> means to drain the incoming queue by invoking application-provided message handlers </li>
</ul>
<p>
The function <a class="el" href="group__DBusConnection.html#g580d8766c23fe5f49418bc7d87b67dc6">dbus_connection_read_write_dispatch()</a> for example does all three of these things, offering a simple alternative to a main loop.<p>
In an application with a main loop, the read/write/dispatch operations are usually separate.<p>
The connection provides <a class="el" href="structDBusWatch.html">DBusWatch</a> and <a class="el" href="structDBusTimeout.html">DBusTimeout</a> objects to the main loop. These are used to know when reading, writing, or dispatching should be performed.<p>
Incoming messages are processed by calling <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a>. <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> runs any handlers registered for the topmost message in the message queue, then discards the message, then returns.<p>
<a class="el" href="group__DBusConnection.html#g893d18d8b36ffb371f16d13645071289">dbus_connection_get_dispatch_status()</a> indicates whether messages are currently in the queue that need dispatching. <a class="el" href="group__DBusConnection.html#g55ff88cd22c0672441c7deffbfb68fbf">dbus_connection_set_dispatch_status_function()</a> allows you to set a function to be used to monitor the dispatch status.<p>
If you're using GLib or Qt add-on libraries for D-Bus, there are special convenience APIs in those libraries that hide all the details of dispatch and watch/timeout monitoring. For example, dbus_connection_setup_with_g_main().<p>
If you aren't using these add-on libraries, but want to process messages asynchronously, you must manually call <a class="el" href="group__DBusConnection.html#g55ff88cd22c0672441c7deffbfb68fbf">dbus_connection_set_dispatch_status_function()</a>, <a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions()</a>, <a class="el" href="group__DBusConnection.html#gb3cbc68eec427e9ce1783b25d44fe93c">dbus_connection_set_timeout_functions()</a> providing appropriate functions to integrate the connection with your application's main loop. This can be tricky to get right; main loops are not simple.<p>
If you don't need to be asynchronous, you can ignore <a class="el" href="structDBusWatch.html">DBusWatch</a>, <a class="el" href="structDBusTimeout.html">DBusTimeout</a>, and <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a>. Instead, <a class="el" href="group__DBusConnection.html#g580d8766c23fe5f49418bc7d87b67dc6">dbus_connection_read_write_dispatch()</a> can be used.<p>
Or, in <em>very</em> simple applications, <a class="el" href="group__DBusConnection.html#g1e40d994ea162ce767e78de1c4988566">dbus_connection_pop_message()</a> may be all you need, allowing you to avoid setting up any handler functions (see <a class="el" href="group__DBusConnection.html#ge00f581e5487408cb294bf71826aff86">dbus_connection_add_filter()</a>, <a class="el" href="group__DBusConnection.html#g24730ca6fd2e9132873962a32df7628c">dbus_connection_register_object_path()</a> for more on handlers).<p>
When you use <a class="el" href="group__DBusConnection.html#ge1cb64f4cf550949b23fd3a756b2f7d0">dbus_connection_send()</a> or one of its variants to send a message, the message is added to the outgoing queue. It's actually written to the network later; either in <a class="el" href="group__DBusWatch.html#gc2acdb1794450ac01a43ec4c3e07ebf7">dbus_watch_handle()</a> invoked by your main loop, or in <a class="el" href="group__DBusConnection.html#g10e68d9d2f41d655a4151ddeb807ff54">dbus_connection_flush()</a> which blocks until it can write out the entire outgoing queue. The GLib/Qt add-on libraries again handle the details here for you by setting up watch functions.<p>
When a connection is disconnected, you are guaranteed to get a signal "Disconnected" from the interface <a class="el" href="group__DBusShared.html#g9ef6478aae637449ec0c5de1679f75ce">DBUS_INTERFACE_LOCAL</a>, path <a class="el" href="group__DBusShared.html#g850990a54a46142ee7c5f8174cc932c1">DBUS_PATH_LOCAL</a>.<p>
You may not drop the last reference to a <a class="el" href="structDBusConnection.html">DBusConnection</a> until that connection has been disconnected.<p>
You may dispatch the unprocessed incoming message queue even if the connection is disconnected. However, "Disconnected" will always be the last message in the queue (obviously no messages are received after disconnection).<p>
After calling <a class="el" href="group__DBusThreads.html#gc7b8a7001befc3eaa8c6b043151008dc">dbus_threads_init()</a>, <a class="el" href="structDBusConnection.html">DBusConnection</a> has thread locks and drops them when invoking user callbacks, so in general is transparently threadsafe. However, <a class="el" href="structDBusMessage.html">DBusMessage</a> does NOT have thread locks; you must not send the same message to multiple <a class="el" href="structDBusConnection.html">DBusConnection</a> if those connections will be used from different threads, for example.<p>
Also, if you dispatch or pop messages from multiple threads, it may work in the sense that it won't crash, but it's tough to imagine sane results; it will be completely unpredictable which messages go to which threads.<p>
It's recommended to dispatch from a single thread.<p>
The most useful function to call from multiple threads at once is <a class="el" href="group__DBusConnection.html#g8d6431f17a9e53c9446d87c2ba8409f0">dbus_connection_send_with_reply_and_block()</a>. That is, multiple threads can make method calls at the same time.<p>
If you aren't using threads, you can use a main loop and <a class="el" href="group__DBusPendingCall.html#g16b67b418b1dc27cfdda6b20f7447670">dbus_pending_call_set_notify()</a> to achieve a similar result. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g0f4e9f850546dfbe3a27edea05e5e590"></a><!-- doxytag: member="dbus-connection.h::DBusAddTimeoutFunction" ref="g0f4e9f850546dfbe3a27edea05e5e590" args="(DBusTimeout *timeout, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(* ) <a class="el" href="group__DBusConnection.html#g0f4e9f850546dfbe3a27edea05e5e590">DBusAddTimeoutFunction</a>(<a class="el" href="structDBusTimeout.html">DBusTimeout</a> *timeout, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when libdbus needs a new timeout to be monitored by the main loop. 
<p>
Returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if it lacks enough memory to add the watch. Set by <a class="el" href="group__DBusConnection.html#gb3cbc68eec427e9ce1783b25d44fe93c">dbus_connection_set_timeout_functions()</a> or <a class="el" href="group__DBusServer.html#gcafa42ffc063a7386db40a975c32d530">dbus_server_set_timeout_functions()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00110">110</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g985b712fc165afa66e5901859b68b9de"></a><!-- doxytag: member="dbus-connection.h::DBusAddWatchFunction" ref="g985b712fc165afa66e5901859b68b9de" args="(DBusWatch *watch, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(* ) <a class="el" href="group__DBusConnection.html#g985b712fc165afa66e5901859b68b9de">DBusAddWatchFunction</a>(<a class="el" href="structDBusWatch.html">DBusWatch</a> *watch, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when libdbus needs a new watch to be monitored by the main loop. 
<p>
Returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if it lacks enough memory to add the watch. Set by <a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions()</a> or <a class="el" href="group__DBusServer.html#ga5723810ea52e9f1815062fd91395892">dbus_server_set_watch_functions()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00091">91</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g141b80629859a4c154c793f08c33d687"></a><!-- doxytag: member="dbus-connection.h::DBusAllowUnixUserFunction" ref="g141b80629859a4c154c793f08c33d687" args="(DBusConnection *connection, unsigned long uid, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(* ) <a class="el" href="group__DBusConnection.html#g141b80629859a4c154c793f08c33d687">DBusAllowUnixUserFunction</a>(<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, unsigned long uid, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called during authentication to check whether the given UNIX user ID is allowed to connect, if the client tried to auth as a UNIX user ID. 
<p>
Normally on Windows this would never happen. Set with <a class="el" href="group__DBusConnection.html#g6b78379badb4c5804344f4f3d87a958a">dbus_connection_set_unix_user_function()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00143">143</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="gf5c1e751b33a480c33f9141ad3ac75d9"></a><!-- doxytag: member="dbus-connection.h::DBusAllowWindowsUserFunction" ref="gf5c1e751b33a480c33f9141ad3ac75d9" args="(DBusConnection *connection, const char *user_sid, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>(* ) <a class="el" href="group__DBusConnection.html#gf5c1e751b33a480c33f9141ad3ac75d9">DBusAllowWindowsUserFunction</a>(<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, const char *user_sid, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called during authentication to check whether the given Windows user ID is allowed to connect, if the client tried to auth as a Windows user ID. 
<p>
Normally on UNIX this would never happen. Set with <a class="el" href="group__DBusConnection.html#ga35ced9ccd29d3366749ae383b120f9c">dbus_connection_set_windows_user_function()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00153">153</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="gd888331dd2737769f669c5df779fe0ef"></a><!-- doxytag: member="dbus-connection.h::DBusDispatchStatusFunction" ref="gd888331dd2737769f669c5df779fe0ef" args="(DBusConnection *connection, DBusDispatchStatus new_status, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#gd888331dd2737769f669c5df779fe0ef">DBusDispatchStatusFunction</a>(<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a> new_status, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when the return value of <a class="el" href="group__DBusConnection.html#g893d18d8b36ffb371f16d13645071289">dbus_connection_get_dispatch_status()</a> may have changed. 
<p>
Set with <a class="el" href="group__DBusConnection.html#g55ff88cd22c0672441c7deffbfb68fbf">dbus_connection_set_dispatch_status_function()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00128">128</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g5cbcefc9b79af6e468eba14d0d7197b2"></a><!-- doxytag: member="dbus-connection.h::DBusHandleMessageFunction" ref="g5cbcefc9b79af6e468eba14d0d7197b2" args="(DBusConnection *connection, DBusMessage *message, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__DBusShared.html#g8244b29230187624c24986c24edab1de">DBusHandlerResult</a>(* ) <a class="el" href="group__DBusConnection.html#g5cbcefc9b79af6e468eba14d0d7197b2">DBusHandleMessageFunction</a>(<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, void *user_data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when a message needs to be handled. 
<p>
The result indicates whether or not more handlers should be run. Set with <a class="el" href="group__DBusConnection.html#ge00f581e5487408cb294bf71826aff86">dbus_connection_add_filter()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00169">169</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g55257eacf7f9f98b1302e6dcc96c6dd4"></a><!-- doxytag: member="dbus-connection.h::DBusObjectPathMessageFunction" ref="g55257eacf7f9f98b1302e6dcc96c6dd4" args="(DBusConnection *connection, DBusMessage *message, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__DBusShared.html#g8244b29230187624c24986c24edab1de">DBusHandlerResult</a>(* ) <a class="el" href="group__DBusConnection.html#g55257eacf7f9f98b1302e6dcc96c6dd4">DBusObjectPathMessageFunction</a>(<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, <a class="el" href="structDBusMessage.html">DBusMessage</a> *message, void *user_data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when a message is sent to a registered object path. 
<p>
Found in <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> which is registered with <a class="el" href="group__DBusConnection.html#g24730ca6fd2e9132873962a32df7628c">dbus_connection_register_object_path()</a> or <a class="el" href="group__DBusConnection.html#gc4473b37bfa74ccf7459959d27e7bc59">dbus_connection_register_fallback()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00374">374</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="gd0fc0a7c19169605633760b2bbe5e3e0"></a><!-- doxytag: member="dbus-connection.h::DBusObjectPathUnregisterFunction" ref="gd0fc0a7c19169605633760b2bbe5e3e0" args="(DBusConnection *connection, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#gd0fc0a7c19169605633760b2bbe5e3e0">DBusObjectPathUnregisterFunction</a>(<a class="el" href="structDBusConnection.html">DBusConnection</a> *connection, void *user_data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when a <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> is unregistered (or its connection is freed). 
<p>
Found in <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00367">367</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g7a3483add4000e5498cd46f64d2b7c9a"></a><!-- doxytag: member="dbus-connection.h::DBusPendingCallNotifyFunction" ref="g7a3483add4000e5498cd46f64d2b7c9a" args="(DBusPendingCall *pending, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#g7a3483add4000e5498cd46f64d2b7c9a">DBusPendingCallNotifyFunction</a>(<a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> *pending, void *user_data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when a pending call now has a reply available. 
<p>
Set with <a class="el" href="group__DBusPendingCall.html#g16b67b418b1dc27cfdda6b20f7447670">dbus_pending_call_set_notify()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00162">162</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="gb11e8c56bd8637deca1439be635f6ca7"></a><!-- doxytag: member="dbus-connection.h::DBusRemoveTimeoutFunction" ref="gb11e8c56bd8637deca1439be635f6ca7" args="(DBusTimeout *timeout, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#gb11e8c56bd8637deca1439be635f6ca7">DBusRemoveTimeoutFunction</a>(<a class="el" href="structDBusTimeout.html">DBusTimeout</a> *timeout, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when libdbus no longer needs a timeout to be monitored by the main loop. 
<p>
Set by <a class="el" href="group__DBusConnection.html#gb3cbc68eec427e9ce1783b25d44fe93c">dbus_connection_set_timeout_functions()</a> or <a class="el" href="group__DBusServer.html#gcafa42ffc063a7386db40a975c32d530">dbus_server_set_timeout_functions()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00123">123</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g6a48c42c4bde24911cae7fda0d1f1589"></a><!-- doxytag: member="dbus-connection.h::DBusRemoveWatchFunction" ref="g6a48c42c4bde24911cae7fda0d1f1589" args="(DBusWatch *watch, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#g6a48c42c4bde24911cae7fda0d1f1589">DBusRemoveWatchFunction</a>(<a class="el" href="structDBusWatch.html">DBusWatch</a> *watch, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when libdbus no longer needs a watch to be monitored by the main loop. 
<p>
Set by <a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions()</a> or <a class="el" href="group__DBusServer.html#ga5723810ea52e9f1815062fd91395892">dbus_server_set_watch_functions()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00103">103</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g1e98eb88ce848204d419495be5e1d228"></a><!-- doxytag: member="dbus-connection.h::DBusTimeoutToggledFunction" ref="g1e98eb88ce848204d419495be5e1d228" args="(DBusTimeout *timeout, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#g1e98eb88ce848204d419495be5e1d228">DBusTimeoutToggledFunction</a>(<a class="el" href="structDBusTimeout.html">DBusTimeout</a> *timeout, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when <a class="el" href="group__DBusTimeout.html#g58954b2edb45ec1632529d35525ea45c">dbus_timeout_get_enabled()</a> may return a different value than it did before. 
<p>
Set by <a class="el" href="group__DBusConnection.html#gb3cbc68eec427e9ce1783b25d44fe93c">dbus_connection_set_timeout_functions()</a> or <a class="el" href="group__DBusServer.html#gcafa42ffc063a7386db40a975c32d530">dbus_server_set_timeout_functions()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00117">117</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g8d21e6bab0bbca3efd2c6d5acb53d468"></a><!-- doxytag: member="dbus-connection.h::DBusWakeupMainFunction" ref="g8d21e6bab0bbca3efd2c6d5acb53d468" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#g8d21e6bab0bbca3efd2c6d5acb53d468">DBusWakeupMainFunction</a>(void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when the main loop's thread should be notified that there's now work to do. 
<p>
Set with <a class="el" href="group__DBusConnection.html#g2b1df13251c7ec348bcba39c0924e881">dbus_connection_set_wakeup_main_function()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00135">135</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="gfa7e0f7856f8ebbe66475979ef54ed9e"></a><!-- doxytag: member="dbus-connection.h::DBusWatchToggledFunction" ref="gfa7e0f7856f8ebbe66475979ef54ed9e" args="(DBusWatch *watch, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ) <a class="el" href="group__DBusConnection.html#gfa7e0f7856f8ebbe66475979ef54ed9e">DBusWatchToggledFunction</a>(<a class="el" href="structDBusWatch.html">DBusWatch</a> *watch, void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when <a class="el" href="group__DBusWatch.html#ge7a91e6d4d1bc187419c47c522e33a8f">dbus_watch_get_enabled()</a> may return a different value than it did before. 
<p>
Set by <a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions()</a> or <a class="el" href="group__DBusServer.html#ga5723810ea52e9f1815062fd91395892">dbus_server_set_watch_functions()</a>. 
<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00097">97</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gbf250a32ff740b2a8c99136e0142d8d2"></a><!-- doxytag: member="dbus-connection.h::DBusDispatchStatus" ref="gbf250a32ff740b2a8c99136e0142d8d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates the status of incoming data on a <a class="el" href="structDBusConnection.html">DBusConnection</a>. 
<p>
This determines whether <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> needs to be called. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93"></a><!-- doxytag: member="DBUS_DISPATCH_DATA_REMAINS" ref="ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93" args="" -->DBUS_DISPATCH_DATA_REMAINS</em>&nbsp;</td><td>
There is more data to potentially convert to messages. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggbf250a32ff740b2a8c99136e0142d8d2cb9bb9daa90f520d5fc9e84de3c5f017"></a><!-- doxytag: member="DBUS_DISPATCH_COMPLETE" ref="ggbf250a32ff740b2a8c99136e0142d8d2cb9bb9daa90f520d5fc9e84de3c5f017" args="" -->DBUS_DISPATCH_COMPLETE</em>&nbsp;</td><td>
All currently available data has been processed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggbf250a32ff740b2a8c99136e0142d8d25af20a035f29cfa67fb8d69fb693b685"></a><!-- doxytag: member="DBUS_DISPATCH_NEED_MEMORY" ref="ggbf250a32ff740b2a8c99136e0142d8d25af20a035f29cfa67fb8d69fb693b685" args="" -->DBUS_DISPATCH_NEED_MEMORY</em>&nbsp;</td><td>
More memory is needed to continue. </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00079">79</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<a class="anchor" name="g0556779e61aeb19eb9cf6b6466bd1b98"></a><!-- doxytag: member="dbus-connection.h::DBusWatchFlags" ref="g0556779e61aeb19eb9cf6b6466bd1b98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DBusConnection.html#g0556779e61aeb19eb9cf6b6466bd1b98">DBusWatchFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates the status of a <a class="el" href="structDBusWatch.html">DBusWatch</a>. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg0556779e61aeb19eb9cf6b6466bd1b98178bd7a88e9bfbb8505db76eb7e0ccc4"></a><!-- doxytag: member="DBUS_WATCH_READABLE" ref="gg0556779e61aeb19eb9cf6b6466bd1b98178bd7a88e9bfbb8505db76eb7e0ccc4" args="" -->DBUS_WATCH_READABLE</em>&nbsp;</td><td>
As in POLLIN. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg0556779e61aeb19eb9cf6b6466bd1b9862ddca29b06bfbbc08bb7f3dfd3d307f"></a><!-- doxytag: member="DBUS_WATCH_WRITABLE" ref="gg0556779e61aeb19eb9cf6b6466bd1b9862ddca29b06bfbbc08bb7f3dfd3d307f" args="" -->DBUS_WATCH_WRITABLE</em>&nbsp;</td><td>
As in POLLOUT. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg0556779e61aeb19eb9cf6b6466bd1b98b1474e26aa5be3d2876dd86bbe452156"></a><!-- doxytag: member="DBUS_WATCH_ERROR" ref="gg0556779e61aeb19eb9cf6b6466bd1b98b1474e26aa5be3d2876dd86bbe452156" args="" -->DBUS_WATCH_ERROR</em>&nbsp;</td><td>
As in POLLERR (can't watch for this, but can be present in current state passed to <a class="el" href="group__DBusWatch.html#gc2acdb1794450ac01a43ec4c3e07ebf7">dbus_watch_handle()</a>). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg0556779e61aeb19eb9cf6b6466bd1b987a361a1a03f463c3c9e57f7368a0bfe4"></a><!-- doxytag: member="DBUS_WATCH_HANGUP" ref="gg0556779e61aeb19eb9cf6b6466bd1b987a361a1a03f463c3c9e57f7368a0bfe4" args="" -->DBUS_WATCH_HANGUP</em>&nbsp;</td><td>
As in POLLHUP (can't watch for it, but can be present in current state passed to <a class="el" href="group__DBusWatch.html#gc2acdb1794450ac01a43ec4c3e07ebf7">dbus_watch_handle()</a>). </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8h-source.html#l00058">58</a> of file <a class="el" href="dbus-connection_8h-source.html">dbus-connection.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge00f581e5487408cb294bf71826aff86"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_add_filter" ref="ge00f581e5487408cb294bf71826aff86" args="(DBusConnection *connection, DBusHandleMessageFunction function, void *user_data, DBusFreeFunction free_data_function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_add_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g5cbcefc9b79af6e468eba14d0d7197b2">DBusHandleMessageFunction</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a message filter. 
<p>
Filters are handlers that are run on all incoming messages, prior to the objects registered with <a class="el" href="group__DBusConnection.html#g24730ca6fd2e9132873962a32df7628c">dbus_connection_register_object_path()</a>. Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback won't be run on the message being processed.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>we don't run filters on messages while blocking without entering the main loop, since filters are run as part of <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a>. This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you're trying to filter METHOD_RETURN for some reason.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>function to handle messages </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>user data to pass to the function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_function</em>&nbsp;</td><td>function to use for freeing user data </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> on success, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if not enough memory. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05568">5568</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-sysdeps-unix_8c-source.html#l02753">_dbus_atomic_inc()</a>, <a class="el" href="dbus-list_8c-source.html#l00270">_dbus_list_append()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-memory_8h-source.html#l00059">dbus_new0</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="dbus-connection_8c-source.html#l00284">filter_list</a>, <a class="el" href="dbus-connection_8c-source.html#l00233">DBusMessageFilter::free_user_data_function</a>, <a class="el" href="dbus-connection_8c-source.html#l00231">DBusMessageFilter::function</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00230">DBusMessageFilter::refcount</a>, <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, and <a class="el" href="dbus-connection_8c-source.html#l00232">DBusMessageFilter::user_data</a>.
</div>
</div><p>
<a class="anchor" name="g728b15c71a492ad244e5a480f1156088"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_allocate_data_slot" ref="g728b15c71a492ad244e5a480f1156088" args="(dbus_int32_t *slot_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_allocate_data_slot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>slot_p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates an integer ID to be used for storing application-specific data on any <a class="el" href="structDBusConnection.html">DBusConnection</a>. 
<p>
The allocated ID may then be used with <a class="el" href="group__DBusConnection.html#g845b4942399f43dd4ac644de7cb9e3ff">dbus_connection_set_data()</a> and <a class="el" href="group__DBusConnection.html#g433fae9844a66d9d078d238e6c723b95">dbus_connection_get_data()</a>. The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it's assumed to be already allocated, and its refcount is incremented.<p>
The allocated slot is global, i.e. all <a class="el" href="structDBusConnection.html">DBusConnection</a> objects will have a slot with the given integer ID reserved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot_p</em>&nbsp;</td><td>address of a global variable storing the slot </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> on failure (no memory) </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05977">5977</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-dataslot_8c-source.html#l00069">_dbus_data_slot_allocator_alloc()</a>.
</div>
</div><p>
<a class="anchor" name="g9d07083c520e291591a68adb78f64094"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_borrow_message" ref="g9d07083c520e291591a68adb78f64094" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="structDBusMessage.html">DBusMessage</a> * dbus_connection_borrow_message           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first-received message from the incoming message queue, leaving it in the queue. 
<p>
If the queue is empty, returns <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.<p>
The caller does not own a reference to the returned message, and must either return it using <a class="el" href="group__DBusConnection.html#g0586da03a01c9c6f332fbea900ef55e3">dbus_connection_return_message()</a> or keep it after calling <a class="el" href="group__DBusConnection.html#g7125d747575b2f596aceaf7be53eae68">dbus_connection_steal_borrowed_message()</a>. No one can get at the message while its borrowed, so return it as quickly as possible and don't keep a reference to it after returning it. If you need to keep the message, make a copy of it.<p>
<a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. This function will block if called during a <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>next message in the incoming queue. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03850">3850</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8h-source.html#l00140">_dbus_assert</a>, <a class="el" href="dbus-list_8c-source.html#l00612">_dbus_list_get_first()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l04378">dbus_connection_get_dispatch_status()</a>, <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a>, <a class="el" href="dbus-connection_8c-source.html#l00268">incoming_messages</a>, <a class="el" href="dbus-connection_8c-source.html#l00271">message_borrowed</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g3e41509b3afdbc22872bacc5754e85c2"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_can_send_type" ref="g3e41509b3afdbc22872bacc5754e85c2" args="(DBusConnection *connection, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_can_send_type           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests whether a certain type can be send via the connection. 
<p>
This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this.<p>
This function can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type to check </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE if the type may be send via the connection </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03105">3105</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l00843">_dbus_transport_can_pass_unix_fd()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-signature_8c-source.html#l00383">dbus_type_is_valid()</a>, <a class="el" href="dbus-protocol_8h-source.html#l00114">DBUS_TYPE_UNIX_FD</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
</div>
</div><p>
<a class="anchor" name="g2522ac5075dfe0a1535471f6e045e1ee"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_close" ref="g2522ac5075dfe0a1535471f6e045e1ee" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes a private connection, so no further data can be sent or received. 
<p>
This disconnects the transport (such as a socket) underlying the connection.<p>
Attempts to send messages after closing a connection are safe, but will result in error replies generated locally in libdbus.<p>
This function does not affect the connection's reference count. It's safe to close a connection more than once; all calls after the first do nothing. It's impossible to "reopen" a connection, a new connection must be created. This function may result in a call to the DBusDispatchStatusFunction set with <a class="el" href="group__DBusConnection.html#g55ff88cd22c0672441c7deffbfb68fbf">dbus_connection_set_dispatch_status_function()</a>, as the disconnect message it generates needs to be dispatched.<p>
If a connection is dropped by the remote application, it will close itself.<p>
You must close a connection prior to releasing the last reference to the connection. If you <a class="el" href="group__DBusConnection.html#g6385ff09bc108238c4429e7c195dab25">dbus_connection_unref()</a> for the last time without closing the connection, the results are undefined; it is a bug in your program and libdbus will try to print a warning.<p>
You may not close a shared connection. Connections created with <a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open()</a> or <a class="el" href="group__DBusBus.html#g77ba5250adb84620f16007e1b023cf26">dbus_bus_get()</a> are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the connection is open. Thus, either the connection is closed and it is OK to drop the last reference, or the connection is open and the app knows it does not have the last reference.<p>
Connections created with <a class="el" href="group__DBusConnection.html#g434e3fc7ee420fd30e2f05e57ff26b1d">dbus_connection_open_private()</a> or <a class="el" href="group__DBusBus.html#g9c62186f19cf3bd3c7c604bdcefb4e09">dbus_bus_get_private()</a> are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling <a class="el" href="group__DBusConnection.html#g2522ac5075dfe0a1535471f6e045e1ee">dbus_connection_close()</a> prior to releasing the last reference, if the connection is not already disconnected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the private (unshared) connection to close </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l02932">2932</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-memory_8c-source.html#l00781">_dbus_current_generation</a>, <a class="el" href="dbus-internals_8c-source.html#l00258">_dbus_warn_check_failed()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l00334">generation</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00315">shareable</a>.
</div>
</div><p>
<a class="anchor" name="g66ba7df50d75f4bda6b6e942430b81c7"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_dispatch" ref="g66ba7df50d75f4bda6b6e942430b81c7" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a> dbus_connection_dispatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Processes any incoming data. 
<p>
If there's incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue.<p>
The incoming data buffer is filled when the connection reads from its underlying transport (such as a socket). Reading usually happens in <a class="el" href="group__DBusWatch.html#gc2acdb1794450ac01a43ec4c3e07ebf7">dbus_watch_handle()</a> or <a class="el" href="group__DBusConnection.html#g371163b4955a6e0bf0f1f70f38390c14">dbus_connection_read_write()</a>.<p>
If there are complete messages in the incoming queue, <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> removes one message from the queue and processes it. Processing has three steps.<p>
First, any method replies are passed to <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> or <a class="el" href="group__DBusConnection.html#g8d6431f17a9e53c9446d87c2ba8409f0">dbus_connection_send_with_reply_and_block()</a> in order to complete the pending method call.<p>
Second, any filters registered with <a class="el" href="group__DBusConnection.html#ge00f581e5487408cb294bf71826aff86">dbus_connection_add_filter()</a> are run. If any filter returns <a class="el" href="group__DBusShared.html#gg8244b29230187624c24986c24edab1deb6df40880a8f322694f14cd2804d3f76">DBUS_HANDLER_RESULT_HANDLED</a> then processing stops after that filter.<p>
Third, if the message is a method call it is forwarded to any registered object path handlers added with <a class="el" href="group__DBusConnection.html#g24730ca6fd2e9132873962a32df7628c">dbus_connection_register_object_path()</a> or <a class="el" href="group__DBusConnection.html#gc4473b37bfa74ccf7459959d27e7bc59">dbus_connection_register_fallback()</a>.<p>
A single call to <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> will process at most one message; it will not clear the entire message queue.<p>
Be careful about calling <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> from inside a message handler, i.e. calling <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>dispatch status, see <a class="el" href="group__DBusConnection.html#g893d18d8b36ffb371f16d13645071289">dbus_connection_get_dispatch_status()</a> </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l04575">4575</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-connection_8c-source.html#l01419">_dbus_connection_ref_unlocked()</a>, <a class="el" href="dbus-hash_8c-source.html#l01074">_dbus_hash_table_lookup_int()</a>, <a class="el" href="dbus-list_8c-source.html#l00242">_dbus_list_alloc_link()</a>, <a class="el" href="dbus-list_8c-source.html#l00542">_dbus_list_clear()</a>, <a class="el" href="dbus-list_8c-source.html#l00697">_dbus_list_copy()</a>, <a class="el" href="dbus-list_8c-source.html#l00759">_dbus_list_foreach()</a>, <a class="el" href="dbus-list_8c-source.html#l00254">_dbus_list_free_link()</a>, <a class="el" href="dbus-list_8c-source.html#l00567">_dbus_list_get_first_link()</a>, <a class="el" href="dbus-list_8h-source.html#l00116">_dbus_list_get_next_link</a>, <a class="el" href="dbus-list_8c-source.html#l00333">_dbus_list_prepend_link()</a>, <a class="el" href="dbus-object-tree_8c-source.html#l00905">_dbus_object_tree_dispatch_and_unlock()</a>, <a class="el" href="dbus-string_8c-source.html#l01114">_dbus_string_append_printf()</a>, <a class="el" href="dbus-string_8c-source.html#l00259">_dbus_string_free()</a>, <a class="el" href="dbus-string_8c-source.html#l00175">_dbus_string_init()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-list_8h-source.html#l00038">DBusList::data</a>, <a class="el" href="dbus-connection_8c-source.html#l02817">dbus_connection_unref()</a>, <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2cb9bb9daa90f520d5fc9e84de3c5f017">DBUS_DISPATCH_COMPLETE</a>, <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a>, <a class="el" href="dbus-connection_8h-source.html#l00083">DBUS_DISPATCH_NEED_MEMORY</a>, <a class="el" href="dbus-protocol_8h-source.html#l00397">DBUS_ERROR_UNKNOWN_METHOD</a>, <a class="el" href="dbus-protocol_8h-source.html#l00399">DBUS_ERROR_UNKNOWN_OBJECT</a>, <a class="el" href="group__DBusShared.html#gg8244b29230187624c24986c24edab1deb6df40880a8f322694f14cd2804d3f76">DBUS_HANDLER_RESULT_HANDLED</a>, <a class="el" href="dbus-shared_8h-source.html#l00070">DBUS_HANDLER_RESULT_NEED_MEMORY</a>, <a class="el" href="group__DBusShared.html#gg8244b29230187624c24986c24edab1decb84b64c92055f2585fe9c29f1e5df68">DBUS_HANDLER_RESULT_NOT_YET_HANDLED</a>, <a class="el" href="dbus-message_8c-source.html#l03300">dbus_message_get_interface()</a>, <a class="el" href="dbus-message_8c-source.html#l03386">dbus_message_get_member()</a>, <a class="el" href="dbus-message_8c-source.html#l01186">dbus_message_get_reply_serial()</a>, <a class="el" href="dbus-message_8c-source.html#l03616">dbus_message_get_signature()</a>, <a class="el" href="dbus-message_8c-source.html#l01745">dbus_message_get_type()</a>, <a class="el" href="dbus-message_8c-source.html#l01493">dbus_message_new_error()</a>, <a class="el" href="dbus-protocol_8h-source.html#l00234">DBUS_MESSAGE_TYPE_METHOD_CALL</a>, <a class="el" href="dbus-message_8c-source.html#l04764">dbus_message_type_to_string()</a>, <a class="el" href="dbus-message_8c-source.html#l01713">dbus_message_unref()</a>, <a class="el" href="dbus-connection_8c-source.html#l00269">expired_messages</a>, <a class="el" href="dbus-connection_8c-source.html#l00284">filter_list</a>, <a class="el" href="dbus-connection_8c-source.html#l00231">DBusMessageFilter::function</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00304">objects</a>, <a class="el" href="dbus-connection_8c-source.html#l00289">pending_replies</a>, and <a class="el" href="dbus-connection_8c-source.html#l00232">DBusMessageFilter::user_data</a>.
</div>
</div><p>
<a class="anchor" name="g10e68d9d2f41d655a4151ddeb807ff54"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_flush" ref="g10e68d9d2f41d655a4151ddeb807ff54" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_flush           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Blocks until the outgoing message queue is empty. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03641">3641</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g7dc8c73d8c3e733f5410d52be84239a0"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_free_data_slot" ref="g7dc8c73d8c3e733f5410d52be84239a0" args="(dbus_int32_t *slot_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_free_data_slot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>slot_p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates a global ID for connection data slots. 
<p>
<a class="el" href="group__DBusConnection.html#g433fae9844a66d9d078d238e6c723b95">dbus_connection_get_data()</a> and <a class="el" href="group__DBusConnection.html#g845b4942399f43dd4ac644de7cb9e3ff">dbus_connection_set_data()</a> may no longer be used with this slot. Existing data stored on existing <a class="el" href="structDBusConnection.html">DBusConnection</a> objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot_p</em>&nbsp;</td><td>address storing the slot to deallocate </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05995">5995</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-dataslot_8c-source.html#l00154">_dbus_data_slot_allocator_free()</a>.
</div>
</div><p>
<a class="anchor" name="gd0ea06307b418616711131ea7bdae8ac"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_free_preallocated_send" ref="gd0ea06307b418616711131ea7bdae8ac" args="(DBusConnection *connection, DBusPreallocatedSend *preallocated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_free_preallocated_send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusPreallocatedSend.html">DBusPreallocatedSend</a> *&nbsp;</td>
          <td class="paramname"> <em>preallocated</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees preallocated message-sending resources from <a class="el" href="group__DBusConnection.html#g6136968eba30e8313e668a622fcfb08d">dbus_connection_preallocate_send()</a>. 
<p>
Should only be called if the preallocated resources are not used to send a message.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>preallocated</em>&nbsp;</td><td>the resources </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03191">3191</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-resources_8c-source.html#l00136">_dbus_counter_unref()</a>, <a class="el" href="dbus-list_8c-source.html#l00254">_dbus_list_free_link()</a>, <a class="el" href="dbus-connection_8c-source.html#l00242">DBusPreallocatedSend::connection</a>, <a class="el" href="dbus-connection_8c-source.html#l00244">DBusPreallocatedSend::counter_link</a>, <a class="el" href="dbus-list_8h-source.html#l00038">DBusList::data</a>, <a class="el" href="dbus-memory_8c-source.html#l00701">dbus_free()</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00243">DBusPreallocatedSend::queue_link</a>.
</div>
</div><p>
<a class="anchor" name="g969b9dafe806c9fe0a54c9d8a565c2e1"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_adt_audit_session_data" ref="g969b9dafe806c9fe0a54c9d8a565c2e1" args="(DBusConnection *connection, void **data, dbus_int32_t *data_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_adt_audit_session_data           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the ADT audit data of the connection if any. 
<p>
Returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the structure pointer is returned. Always returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> prior to authenticating the connection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>return location for audit data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_size</em>&nbsp;</td><td>return location for length of audit data </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if audit data is filled in with a valid ucred pointer </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05290">5290</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01377">_dbus_transport_get_adt_audit_session_data()</a>, <a class="el" href="dbus-transport_8c-source.html#l00724">_dbus_transport_try_to_authenticate()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g433fae9844a66d9d078d238e6c723b95"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_data" ref="g433fae9844a66d9d078d238e6c723b95" args="(DBusConnection *connection, dbus_int32_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void * dbus_connection_get_data           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves data previously set with <a class="el" href="group__DBusConnection.html#g845b4942399f43dd4ac644de7cb9e3ff">dbus_connection_set_data()</a>. 
<p>
The slot must still be allocated (must not have been freed).<p>
<dl compact><dt><b>Note:</b></dt><dd>This function does not take the main thread lock on <a class="el" href="structDBusConnection.html">DBusConnection</a>, which allows it to be used from inside watch and timeout functions. (See the note in docs for <a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions()</a>.) A side effect of this is that you need to know there's a reference held on the connection while invoking <a class="el" href="group__DBusConnection.html#g433fae9844a66d9d078d238e6c723b95">dbus_connection_get_data()</a>, or the connection could be finalized during <a class="el" href="group__DBusConnection.html#g433fae9844a66d9d078d238e6c723b95">dbus_connection_get_data()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>the slot to get data from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the data, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> if not found </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06074">6074</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-dataslot_8c-source.html#l00285">_dbus_data_slot_list_get()</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00287">slot_list</a>.
</div>
</div><p>
<a class="anchor" name="g893d18d8b36ffb371f16d13645071289"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_dispatch_status" ref="g893d18d8b36ffb371f16d13645071289" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusConnection.html#gbf250a32ff740b2a8c99136e0142d8d2">DBusDispatchStatus</a> dbus_connection_get_dispatch_status           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current state of the incoming message queue. 
<p>
<a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a> indicates that the message queue may contain messages. <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2cb9bb9daa90f520d5fc9e84de3c5f017">DBUS_DISPATCH_COMPLETE</a> indicates that the incoming queue is empty. <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d25af20a035f29cfa67fb8d69fb693b685">DBUS_DISPATCH_NEED_MEMORY</a> indicates that there could be data, but we can't know for sure without more memory.<p>
To process the incoming message queue, use <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> or (in rare cases) <a class="el" href="group__DBusConnection.html#g1e40d994ea162ce767e78de1c4988566">dbus_connection_pop_message()</a>.<p>
Note, <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a> really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it's possible to see a status of <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a> but not have a message yet.<p>
In particular this happens on initial connection, because all sorts of authentication protocol stuff has to be parsed before the first message arrives.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>current dispatch status </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l04378">4378</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2cb9bb9daa90f520d5fc9e84de3c5f017">DBUS_DISPATCH_COMPLETE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
<p>
Referenced by <a class="el" href="dbus-connection_8c-source.html#l03850">dbus_connection_borrow_message()</a>, and <a class="el" href="dbus-connection_8c-source.html#l04091">dbus_connection_pop_message()</a>.
</div>
</div><p>
<a class="anchor" name="ga6c5d523e16d8a5b9316c92d9ff1ac17"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_is_anonymous" ref="ga6c5d523e16d8a5b9316c92d9ff1ac17" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_is_anonymous           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether the connection is not authenticated as a specific user. 
<p>
If the connection is not authenticated, this function returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, and if it is authenticated but as an anonymous user, it returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>. If it is authenticated as a specific user, then this returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>. (Note that if the connection was authenticated as anonymous then disconnected, this function still returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.)<p>
If the connection is not anonymous, you can use <a class="el" href="group__DBusConnection.html#gef670c3a8170ab9c719ec955252459d0">dbus_connection_get_unix_user()</a> and <a class="el" href="group__DBusConnection.html#g2b3cb488f1922aeecdeafdcb110e91a8">dbus_connection_get_windows_user()</a> to see who it's authorized as.<p>
If you want to prevent non-anonymous authorization, use <a class="el" href="group__DBusServer.html#g309e5f1510c74c4b221d12d874d53341">dbus_server_set_auth_mechanisms()</a> to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if not authenticated or authenticated as anonymous </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03029">3029</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l00821">_dbus_transport_get_is_anonymous()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g2f1fa02c9897b6f07f4d33c862de4a1d"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_is_authenticated" ref="g2f1fa02c9897b6f07f4d33c862de4a1d" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_is_authenticated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether the connection was authenticated. 
<p>
(Note that if the connection was authenticated then disconnected, this function still returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the connection was ever authenticated </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l02995">2995</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l00724">_dbus_transport_try_to_authenticate()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g611ae94556af36fe30bfb547366ca4e1"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_is_connected" ref="g611ae94556af36fe30bfb547366ca4e1" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_is_connected           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether the connection is currently open. 
<p>
A connection may become disconnected when the remote application closes its end, or exits; a connection may also be disconnected with <a class="el" href="group__DBusConnection.html#g2522ac5075dfe0a1535471f6e045e1ee">dbus_connection_close()</a>.<p>
There are not separate states for "closed" and "disconnected," the two terms are synonymous. This function should really be called get_is_open() but for historical reasons is not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the connection is still alive. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l02973">2973</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g7a459e64d7dca7b592136cec0a73422c"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_max_message_size" ref="g7a459e64d7dca7b592136cec0a73422c" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT long dbus_connection_get_max_message_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="group__DBusConnection.html#g0d783462274a6c71d3767f5821c29ce9">dbus_connection_set_max_message_size()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the max size of a single message </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06132">6132</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01225">_dbus_transport_get_max_message_size()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g18abaca9a512dbb7b6f921c3df6875d9"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_max_message_unix_fds" ref="g18abaca9a512dbb7b6f921c3df6875d9" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT long dbus_connection_get_max_message_unix_fds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="group__DBusConnection.html#g2aadce7d15c0e11983363912292b3fcd">dbus_connection_set_max_message_unix_fds()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the max numer of unix fds of a single message </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06171">6171</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01237">_dbus_transport_get_max_message_unix_fds()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g376529acf41d1d34b4f46c0d9d515c85"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_max_received_size" ref="g376529acf41d1d34b4f46c0d9d515c85" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT long dbus_connection_get_max_received_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="group__DBusConnection.html#g6565d75f16e6e803372b2ae3d94d991b">dbus_connection_set_max_received_size()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the max size of all live messages </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06227">6227</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01285">_dbus_transport_get_max_received_size()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g219f31132338616f82dc975c070ff418"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_max_received_unix_fds" ref="g219f31132338616f82dc975c070ff418" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT long dbus_connection_get_max_received_unix_fds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value set by <a class="el" href="group__DBusConnection.html#g81e63dc6d9298e8a7f92c0d93d0e80b3">dbus_connection_set_max_received_unix_fds()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the max unix fds of all live messages </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06269">6269</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01297">_dbus_transport_get_max_received_unix_fds()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g08ee6e70b74c294fe24d0f391f16db24"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_object_path_data" ref="g08ee6e70b74c294fe24d0f391f16db24" args="(DBusConnection *connection, const char *path, void **data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_object_path_data           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>data_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the user data passed to <a class="el" href="group__DBusConnection.html#g24730ca6fd2e9132873962a32df7628c">dbus_connection_register_object_path()</a> or <a class="el" href="group__DBusConnection.html#gc4473b37bfa74ccf7459959d27e7bc59">dbus_connection_register_fallback()</a>. 
<p>
If nothing was registered at this path, the data is filled in with <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>the path you registered with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_p</em>&nbsp;</td><td>location to store the user data, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if not enough memory </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05898">5898</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-object-tree_8c-source.html#l01244">_dbus_decompose_path()</a>, <a class="el" href="dbus-object-tree_8c-source.html#l01077">_dbus_object_tree_get_user_data_unlocked()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-memory_8c-source.html#l00749">dbus_free_string_array()</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00304">objects</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
</div>
</div><p>
<a class="anchor" name="g47aff801f586e7116f9c54532bb1baf9"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_outgoing_size" ref="g47aff801f586e7116f9c54532bb1baf9" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT long dbus_connection_get_outgoing_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the approximate size in bytes of all messages in the outgoing message queue. 
<p>
The size is approximate in that you shouldn't use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes that have been queued up but not sent </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06292">6292</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-resources_8c-source.html#l00274">_dbus_counter_get_size_value()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00278">outgoing_counter</a>.
</div>
</div><p>
<a class="anchor" name="gd218838fdaa8d36c606723c63e96f453"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_outgoing_unix_fds" ref="gd218838fdaa8d36c606723c63e96f453" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT long dbus_connection_get_outgoing_unix_fds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the approximate number of uni fds of all messages in the outgoing message queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of unix fds that have been queued up but not sent </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06353">6353</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-resources_8c-source.html#l00286">_dbus_counter_get_unix_fd_value()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00278">outgoing_counter</a>.
</div>
</div><p>
<a class="anchor" name="ge6c19e146a37f9de6a06c1617874bed9"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_server_id" ref="ge6c19e146a37f9de6a06c1617874bed9" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT char * dbus_connection_get_server_id           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the ID of the server address we are authenticated to, if this connection is on the client side. 
<p>
If the connection is on the server side, this will always return <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> - use <a class="el" href="group__DBusServer.html#g3b2920b3c65836113781d9dd00d1e139">dbus_server_get_id()</a> to get the ID of your own server, if you are the server side.<p>
If a client-side connection is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete.<p>
In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID.<p>
If you want an ID that identifies an entire session bus, look at <a class="el" href="group__DBusBus.html#g18314500e7f6890a79bddbeace5df5f9">dbus_bus_get_id()</a> instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus).<p>
You can also get a machine ID; see <a class="el" href="group__DBusMisc.html#g2b21c9a12fea5f92763441c65ccbfcf9">dbus_get_local_machine_id()</a> to get the machine you are on. There isn't a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end.<p>
The D-Bus specification describes the server ID and other IDs in a bit more detail.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the server ID or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> if no memory or the connection is server-side </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03074">3074</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8c-source.html#l00537">_dbus_strdup()</a>, <a class="el" href="dbus-transport_8c-source.html#l00869">_dbus_transport_get_server_id()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g1c14590d77b148390bde9e82a7544434"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_socket" ref="g1c14590d77b148390bde9e82a7544434" args="(DBusConnection *connection, int *fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_socket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the underlying Windows or UNIX socket file descriptor of the connection, if any. 
<p>
DO NOT read or write to the file descriptor, or try to select() on it; use <a class="el" href="structDBusWatch.html">DBusWatch</a> for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use <a class="el" href="group__DBusWatch.html#g91308f393d41b31babda17c83833517f">dbus_watch_get_socket()</a> and so forth.<p>
If the connection is not socket-based, this function will return FALSE, even if the connection does have a file descriptor of some kind. i.e. this function always returns specifically a socket file descriptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>return location for the file descriptor. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if fd is successfully obtained. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05174">5174</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l00951">_dbus_transport_get_socket_fd()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-sysdeps_8h-source.html#l00150">DBUS_SOCKET_INIT</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
<p>
Referenced by <a class="el" href="dbus-connection_8c-source.html#l05144">dbus_connection_get_unix_fd()</a>.
</div>
</div><p>
<a class="anchor" name="g38297f511f4124accdfa68c321e081cc"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_unix_fd" ref="g38297f511f4124accdfa68c321e081cc" args="(DBusConnection *connection, int *fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_unix_fd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the UNIX file descriptor of the connection, if any. 
<p>
This can be used for SELinux access control checks with getpeercon() for example. DO NOT read or write to the file descriptor, or try to select() on it; use <a class="el" href="structDBusWatch.html">DBusWatch</a> for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use <a class="el" href="group__DBusWatch.html#g15df7f6120ead3e09bec8a70d3c43c0d">dbus_watch_get_unix_fd()</a> and so forth.<p>
If the connection is socket-based, you can also use <a class="el" href="group__DBusConnection.html#g1c14590d77b148390bde9e82a7544434">dbus_connection_get_socket()</a>, which will work on Windows too. This function always fails on Windows.<p>
Right now the returned descriptor is always a socket, but that is not guaranteed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>return location for the file descriptor. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if fd is successfully obtained. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05144">5144</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-connection_8c-source.html#l05174">dbus_connection_get_socket()</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="geebeadcafa87e2d30eed4296f26fb73c"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_unix_process_id" ref="geebeadcafa87e2d30eed4296f26fb73c" args="(DBusConnection *connection, unsigned long *pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_unix_process_id           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>pid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the process ID of the connection if any. 
<p>
Returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the pid is filled in. Always returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> prior to authenticating the connection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>return location for the process ID </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if uid is filled in with a valid process ID </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05257">5257</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01343">_dbus_transport_get_unix_process_id()</a>, <a class="el" href="dbus-transport_8c-source.html#l00724">_dbus_transport_try_to_authenticate()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="gef670c3a8170ab9c719ec955252459d0"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_unix_user" ref="gef670c3a8170ab9c719ec955252459d0" args="(DBusConnection *connection, unsigned long *uid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_unix_user           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>uid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the UNIX user ID of the connection if known. 
<p>
Returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the uid is filled in. Always returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> prior to authenticating the connection.<p>
The UID is only read by servers from clients; clients can't usually get the UID of servers, because servers do not authenticate to clients. The returned UID is the UID the connection authenticated as.<p>
The message bus is a server and the apps connecting to the bus are clients.<p>
You can ask the bus to tell you the UID of another connection though if you like; this is done with <a class="el" href="group__DBusBus.html#g24d782c710f3d82caf1b1ed582dcf474">dbus_bus_get_unix_user()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uid</em>&nbsp;</td><td>return location for the user ID </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if uid is filled in with a valid user ID </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05221">5221</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8h-source.html#l00140">_dbus_assert</a>, <a class="el" href="dbus-transport_8c-source.html#l01310">_dbus_transport_get_unix_user()</a>, <a class="el" href="dbus-transport_8c-source.html#l00724">_dbus_transport_try_to_authenticate()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g2b3cb488f1922aeecdeafdcb110e91a8"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_get_windows_user" ref="g2b3cb488f1922aeecdeafdcb110e91a8" args="(DBusConnection *connection, char **windows_sid_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_get_windows_user           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>windows_sid_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the Windows user SID of the connection if known. 
<p>
Returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the ID is filled in. Always returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> prior to authenticating the connection.<p>
The user is only read by servers from clients; clients can't usually get the user of servers, because servers do not authenticate to clients. The returned user is the user the connection authenticated as.<p>
The message bus is a server and the apps connecting to the bus are clients.<p>
The returned user string has to be freed with <a class="el" href="group__DBusMemory.html#g34e666b19b015035a9a31e53da84b39a">dbus_free()</a>.<p>
The return value indicates whether the user SID is available; if it's available but we don't have the memory to copy it, then the return value is <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> is given as the SID.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>We would like to be able to say "You can ask the bus to tell you the user of another connection though if you like; this is done with dbus_bus_get_windows_user()." But this has to be implemented in bus/driver.c and <a class="el" href="dbus-bus_8c-source.html">dbus/dbus-bus.c</a>, and is pointless anyway since on Windows we only use the session bus for now.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>windows_sid_p</em>&nbsp;</td><td>return location for an allocated copy of the user ID, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> if no memory </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if user is available (returned value may be <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> anyway if no memory) </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05414">5414</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8h-source.html#l00140">_dbus_assert</a>, <a class="el" href="dbus-transport_8c-source.html#l01463">_dbus_transport_get_windows_user()</a>, <a class="el" href="dbus-transport_8c-source.html#l00724">_dbus_transport_try_to_authenticate()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="gc40563ec4c0e309d936daf3163ba9bb7"></a><!-- doxytag: member="dbus-connection.h::dbus_connection_has_messages_to_send" ref="gc40563ec4c0e309d936daf3163ba9bb7" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_has_messages_to_send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether there are messages in the outgoing message queue. 
<p>
Use <a class="el" href="group__DBusConnection.html#g10e68d9d2f41d655a4151ddeb807ff54">dbus_connection_flush()</a> to block until all outgoing messages have been written to the underlying transport (such as a socket).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the outgoing queue is non-empty. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l00588">588</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-connection_8c-source.html#l00572">_dbus_connection_has_messages_to_send_unlocked()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g3e9de2067d0eed66ef73230fae8d8be2"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_list_registered" ref="g3e9de2067d0eed66ef73230fae8d8be2" args="(DBusConnection *connection, const char *parent_path, char ***child_entries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_list_registered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>parent_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&nbsp;</td>
          <td class="paramname"> <em>child_entries</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lists the registered fallback handlers and object path handlers at the given parent_path. 
<p>
The returned array should be freed with <a class="el" href="group__DBusMemory.html#gc200b2dbc8b3f6ecac4d42426fb97b40">dbus_free_string_array()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent_path</em>&nbsp;</td><td>the path to list the child handlers of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child_entries</em>&nbsp;</td><td>returns <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>-terminated array of children </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if no memory to allocate the child entries </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05935">5935</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-object-tree_8c-source.html#l01244">_dbus_decompose_path()</a>, <a class="el" href="dbus-object-tree_8c-source.html#l01208">_dbus_object_tree_list_registered_and_unlock()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-memory_8c-source.html#l00749">dbus_free_string_array()</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00304">objects</a>.
</div>
</div><p>
<a class="anchor" name="gcd32f819820266598c6b6847dfddaf9c"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_open" ref="gcd32f819820266598c6b6847dfddaf9c" args="(const char *address, DBusError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="structDBusConnection.html">DBusConnection</a> * dbus_connection_open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusError.html">DBusError</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a connection to a remote address. 
<p>
If a connection to the given address already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to <a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open()</a> asks to connect to the same server.<p>
Use <a class="el" href="group__DBusConnection.html#g434e3fc7ee420fd30e2f05e57ff26b1d">dbus_connection_open_private()</a> to get a dedicated connection not shared with other callers of <a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open()</a>.<p>
If the open fails, the function returns <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and provides a reason for the failure in the error parameter. Pass <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> for the error parameter if you aren't interested in the reason for failure.<p>
Because this connection is shared, no user of the connection may call <a class="el" href="group__DBusConnection.html#g2522ac5075dfe0a1535471f6e045e1ee">dbus_connection_close()</a>. However, when you are done with the connection you should call <a class="el" href="group__DBusConnection.html#g6385ff09bc108238c4429e7c195dab25">dbus_connection_unref()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Prefer <a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open()</a> to <a class="el" href="group__DBusConnection.html#g434e3fc7ee420fd30e2f05e57ff26b1d">dbus_connection_open_private()</a> unless you have good reason; connections are expensive enough that it's wasteful to create lots of connections to the same server.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>the address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>address where an error can be returned. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>new connection, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> on failure. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l02616">2616</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
</div>
</div><p>
<a class="anchor" name="g434e3fc7ee420fd30e2f05e57ff26b1d"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_open_private" ref="g434e3fc7ee420fd30e2f05e57ff26b1d" args="(const char *address, DBusError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="structDBusConnection.html">DBusConnection</a> * dbus_connection_open_private           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusError.html">DBusError</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a new, dedicated connection to a remote address. 
<p>
Unlike <a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open()</a>, always creates a new connection. This connection will not be saved or recycled by libdbus.<p>
If the open fails, the function returns <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and provides a reason for the failure in the error parameter. Pass <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> for the error parameter if you aren't interested in the reason for failure.<p>
When you are done with this connection, you must <a class="el" href="group__DBusConnection.html#g2522ac5075dfe0a1535471f6e045e1ee">dbus_connection_close()</a> to disconnect it, and <a class="el" href="group__DBusConnection.html#g6385ff09bc108238c4429e7c195dab25">dbus_connection_unref()</a> to free the connection object.<p>
(The <a class="el" href="group__DBusConnection.html#g2522ac5075dfe0a1535471f6e045e1ee">dbus_connection_close()</a> can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.)<p>
<dl compact><dt><b>Note:</b></dt><dd>Prefer <a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open()</a> to <a class="el" href="group__DBusConnection.html#g434e3fc7ee420fd30e2f05e57ff26b1d">dbus_connection_open_private()</a> unless you have good reason; connections are expensive enough that it's wasteful to create lots of connections to the same server.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>the address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>address where an error can be returned. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>new connection, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> on failure. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l02659">2659</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g1e40d994ea162ce767e78de1c4988566"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_pop_message" ref="g1e40d994ea162ce767e78de1c4988566" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="structDBusMessage.html">DBusMessage</a> * dbus_connection_pop_message           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first-received message from the incoming message queue, removing it from the queue. 
<p>
The caller owns a reference to the returned message. If the queue is empty, returns <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.<p>
This function bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a>. Popping messages manually is only useful in very simple programs that don't share a <a class="el" href="structDBusConnection.html">DBusConnection</a> with any libraries or other modules.<p>
There is a lock that covers all ways of accessing the incoming message queue, so <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a>, <a class="el" href="group__DBusConnection.html#g1e40d994ea162ce767e78de1c4988566">dbus_connection_pop_message()</a>, <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a>, etc. will all block while one of the others in the group is running.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>next message in the incoming queue. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l04091">4091</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l04378">dbus_connection_get_dispatch_status()</a>, <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g6136968eba30e8313e668a622fcfb08d"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_preallocate_send" ref="g6136968eba30e8313e668a622fcfb08d" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="structDBusPreallocatedSend.html">DBusPreallocatedSend</a> * dbus_connection_preallocate_send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. 
<p>
Allows apps to create a future guarantee that they can send a message regardless of memory shortages.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection we're preallocating for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the preallocated resources, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03165">3165</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g371163b4955a6e0bf0f1f70f38390c14"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_read_write" ref="g371163b4955a6e0bf0f1f70f38390c14" args="(DBusConnection *connection, int timeout_milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_read_write           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_milliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is intended for use with applications that don't want to write a main loop and deal with <a class="el" href="structDBusWatch.html">DBusWatch</a> and <a class="el" href="structDBusTimeout.html">DBusTimeout</a>. 
<p>
See also <a class="el" href="group__DBusConnection.html#g580d8766c23fe5f49418bc7d87b67dc6">dbus_connection_read_write_dispatch()</a>.<p>
As long as the connection is open, this function will block until it can read or write, then read or write, then return <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.<p>
If the connection is closed, the function returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>.<p>
The return value indicates whether reading or writing is still possible, i.e. whether the connection is connected.<p>
Note that even after disconnection, messages may remain in the incoming queue that need to be processed. <a class="el" href="group__DBusConnection.html#g580d8766c23fe5f49418bc7d87b67dc6">dbus_connection_read_write_dispatch()</a> dispatches incoming messages for you; with <a class="el" href="group__DBusConnection.html#g371163b4955a6e0bf0f1f70f38390c14">dbus_connection_read_write()</a> you have to arrange to drain the incoming queue yourself.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_milliseconds</em>&nbsp;</td><td>max time to block or -1 for infinite </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if still connected </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03801">3801</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g580d8766c23fe5f49418bc7d87b67dc6"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_read_write_dispatch" ref="g580d8766c23fe5f49418bc7d87b67dc6" args="(DBusConnection *connection, int timeout_milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_read_write_dispatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_milliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is intended for use with applications that don't want to write a main loop and deal with <a class="el" href="structDBusWatch.html">DBusWatch</a> and <a class="el" href="structDBusTimeout.html">DBusTimeout</a>. 
<p>
An example usage would be:<p>
<div class="fragment"><pre class="fragment">   <span class="keywordflow">while</span> (<a class="code" href="group__DBusConnection.html#g580d8766c23fe5f49418bc7d87b67dc6">dbus_connection_read_write_dispatch</a> (connection, -1))
     ; <span class="comment">// empty loop body</span>
</pre></div><p>
In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the connection (the disconnected signal) is processed.<p>
If there are messages to dispatch, this function will <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> once, and return. If there are no messages to dispatch, this function will block until it can read or write, then read or write, then return.<p>
The way to think of this function is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes this function unsuitable for applications that do more than just react to received messages.<p>
The return value indicates whether the disconnect message has been processed, NOT whether the connection is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_milliseconds</em>&nbsp;</td><td>max time to block or -1 for infinite </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if the disconnect message has not been processed </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03769">3769</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
</div>
</div><p>
<a class="anchor" name="ge34751e15f114217e5ad10c663e2ef2e"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_ref" ref="ge34751e15f114217e5ad10c663e2ef2e" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="structDBusConnection.html">DBusConnection</a> * dbus_connection_ref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increments the reference count of a <a class="el" href="structDBusConnection.html">DBusConnection</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the connection. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l02681">2681</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-sysdeps-unix_8c-source.html#l02753">_dbus_atomic_inc()</a>, <a class="el" href="dbus-memory_8c-source.html#l00781">_dbus_current_generation</a>, <a class="el" href="dbus-connection_8c-source.html#l00334">generation</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00258">refcount</a>.
</div>
</div><p>
<a class="anchor" name="gc4473b37bfa74ccf7459959d27e7bc59"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_register_fallback" ref="gc4473b37bfa74ccf7459959d27e7bc59" args="(DBusConnection *connection, const char *path, const DBusObjectPathVTable *vtable, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_register_fallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *&nbsp;</td>
          <td class="paramname"> <em>vtable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a fallback handler for a given subsection of the object hierarchy. 
<p>
The given vtable handles messages at or below the given path. You can use this to establish a default message handling policy for a whole "subdirectory."<p>
It is a bug to call this function for object paths which already have a handler. Use <a class="el" href="group__DBusConnection.html#g8e9d2d4ff17c3071124e4993d1536ed4">dbus_connection_try_register_fallback()</a> if this might be the case.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>a '/' delimited string of path elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtable</em>&nbsp;</td><td>the virtual table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>data to pass to functions in the vtable </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if an error (<a class="el" href="group__DBusProtocol.html#gc32eaf0b92f798307853cd4fe0cf11c2">DBUS_ERROR_NO_MEMORY</a> or <a class="el" href="group__DBusProtocol.html#g6a4358a62f0cd68d637532772475e576">DBUS_ERROR_OBJECT_PATH_IN_USE</a>) occured </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05831">5831</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8c-source.html#l00230">_dbus_warn()</a>, <a class="el" href="dbus-errors_8c-source.html#l00211">dbus_error_free()</a>, <a class="el" href="dbus-errors_8c-source.html#l00302">dbus_error_has_name()</a>, <a class="el" href="dbus-errors_8h-source.html#l00062">DBUS_ERROR_INIT</a>, <a class="el" href="dbus-protocol_8h-source.html#l00450">DBUS_ERROR_OBJECT_PATH_IN_USE</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
</div>
</div><p>
<a class="anchor" name="g24730ca6fd2e9132873962a32df7628c"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_register_object_path" ref="g24730ca6fd2e9132873962a32df7628c" args="(DBusConnection *connection, const char *path, const DBusObjectPathVTable *vtable, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_register_object_path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *&nbsp;</td>
          <td class="paramname"> <em>vtable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a handler for a given path in the object hierarchy. 
<p>
The given vtable handles messages sent to exactly the given path.<p>
It is a bug to call this function for object paths which already have a handler. Use <a class="el" href="group__DBusConnection.html#g708b1e108feed18f5775ff404c9dda4b">dbus_connection_try_register_object_path()</a> if this might be the case.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>a '/' delimited string of path elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtable</em>&nbsp;</td><td>the virtual table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>data to pass to functions in the vtable </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if an error (<a class="el" href="group__DBusProtocol.html#gc32eaf0b92f798307853cd4fe0cf11c2">DBUS_ERROR_NO_MEMORY</a> or <a class="el" href="group__DBusProtocol.html#g6a4358a62f0cd68d637532772475e576">DBUS_ERROR_OBJECT_PATH_IN_USE</a>) ocurred </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05759">5759</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8c-source.html#l00230">_dbus_warn()</a>, <a class="el" href="dbus-errors_8c-source.html#l00211">dbus_error_free()</a>, <a class="el" href="dbus-errors_8c-source.html#l00302">dbus_error_has_name()</a>, <a class="el" href="dbus-errors_8h-source.html#l00062">DBUS_ERROR_INIT</a>, <a class="el" href="dbus-protocol_8h-source.html#l00450">DBUS_ERROR_OBJECT_PATH_IN_USE</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g5e7f1dad410506a8a6f5182c55e7c4fe"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_remove_filter" ref="g5e7f1dad410506a8a6f5182c55e7c4fe" args="(DBusConnection *connection, DBusHandleMessageFunction function, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_remove_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g5cbcefc9b79af6e468eba14d0d7197b2">DBusHandleMessageFunction</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a previously-added message filter. 
<p>
It is a programming error to call this function for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>the handler to remove </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>user data for the handler to remove </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05620">5620</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-list_8c-source.html#l00580">_dbus_list_get_last_link()</a>, <a class="el" href="dbus-list_8h-source.html#l00117">_dbus_list_get_prev_link</a>, <a class="el" href="dbus-list_8c-source.html#l00527">_dbus_list_remove_link()</a>, <a class="el" href="dbus-internals_8c-source.html#l00258">_dbus_warn_check_failed()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-list_8h-source.html#l00038">DBusList::data</a>, <a class="el" href="dbus-connection_8c-source.html#l00284">filter_list</a>, <a class="el" href="dbus-connection_8c-source.html#l00233">DBusMessageFilter::free_user_data_function</a>, <a class="el" href="dbus-connection_8c-source.html#l00231">DBusMessageFilter::function</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00232">DBusMessageFilter::user_data</a>.
</div>
</div><p>
<a class="anchor" name="g0586da03a01c9c6f332fbea900ef55e3"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_return_message" ref="g0586da03a01c9c6f332fbea900ef55e3" args="(DBusConnection *connection, DBusMessage *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_return_message           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to return a message after peeking at it using <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a>. 
<p>
Only called if message from <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a> was non-<a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the message from <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a> </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03901">3901</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8h-source.html#l00140">_dbus_assert</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l00312">dispatch_acquired</a>, <a class="el" href="dbus-connection_8c-source.html#l00271">message_borrowed</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="ge1cb64f4cf550949b23fd3a756b2f7d0"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_send" ref="ge1cb64f4cf550949b23fd3a756b2f7d0" args="(DBusConnection *connection, DBusMessage *message, dbus_uint32_t *serial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>serial</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a message to the outgoing message queue. 
<p>
Does not block to write the message to the network; that happens asynchronously. To force the message to be written, call <a class="el" href="group__DBusConnection.html#g10e68d9d2f41d655a4151ddeb807ff54">dbus_connection_flush()</a> however it is not necessary to call <a class="el" href="group__DBusConnection.html#g10e68d9d2f41d655a4151ddeb807ff54">dbus_connection_flush()</a> by hand; the message will be sent the next time the main loop is run. <a class="el" href="group__DBusConnection.html#g10e68d9d2f41d655a4151ddeb807ff54">dbus_connection_flush()</a> should only be used, for example, if the application was expected to exit before running the main loop.<p>
Because this only queues the message, the only reason it can fail is lack of memory. Even if the connection is disconnected, no error will be returned. If the function fails due to lack of memory, it returns <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>. The function will never fail for other reasons; even if the connection is disconnected, you can queue an outgoing message, though obviously it won't be sent.<p>
The message serial is used by the remote application to send a reply; see <a class="el" href="group__DBusMessage.html#g390710c25564c80025a006c376da2030">dbus_message_get_serial()</a> or the D-Bus specification.<p>
<a class="el" href="group__DBusMessage.html#gb69441efe683918f6a82469c8763f464">dbus_message_unref()</a> can be called as soon as this method returns as the message queue will hold its own ref until the message is sent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the message to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>serial</em>&nbsp;</td><td>return location for message serial, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> if you don't care </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> on success. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03302">3302</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-connection_8c-source.html#l02098">_dbus_connection_send_and_unlock()</a>, <a class="el" href="dbus-transport_8c-source.html#l00843">_dbus_transport_can_pass_unix_fd()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="dbus-message-private_8h-source.html#l00129">DBusMessage::n_unix_fds</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g2fea5f972d1bfe7bcde8c0ec65ca9e90"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_send_preallocated" ref="g2fea5f972d1bfe7bcde8c0ec65ca9e90" args="(DBusConnection *connection, DBusPreallocatedSend *preallocated, DBusMessage *message, dbus_uint32_t *client_serial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_send_preallocated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusPreallocatedSend.html">DBusPreallocatedSend</a> *&nbsp;</td>
          <td class="paramname"> <em>preallocated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#gf513803b030613a669cc7ef199f90a8b">dbus_uint32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>client_serial</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message using preallocated resources. 
<p>
This function cannot fail. It works identically to <a class="el" href="group__DBusConnection.html#ge1cb64f4cf550949b23fd3a756b2f7d0">dbus_connection_send()</a> in other respects. Preallocated resources comes from <a class="el" href="group__DBusConnection.html#g6136968eba30e8313e668a622fcfb08d">dbus_connection_preallocate_send()</a>. This function "consumes" the preallocated resources, they need not be freed separately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>preallocated</em>&nbsp;</td><td>the preallocated resources </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the message to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>client_serial</em>&nbsp;</td><td>return location for client serial assigned to the message </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03217">3217</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l00843">_dbus_transport_can_pass_unix_fd()</a>, <a class="el" href="dbus-connection_8c-source.html#l00242">DBusPreallocatedSend::connection</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-message_8c-source.html#l03300">dbus_message_get_interface()</a>, <a class="el" href="dbus-message_8c-source.html#l03386">dbus_message_get_member()</a>, <a class="el" href="dbus-message_8c-source.html#l01745">dbus_message_get_type()</a>, <a class="el" href="dbus-protocol_8h-source.html#l00234">DBUS_MESSAGE_TYPE_METHOD_CALL</a>, <a class="el" href="dbus-protocol_8h-source.html#l00240">DBUS_MESSAGE_TYPE_SIGNAL</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="ga215df7ab7ca6dce7be153c6b9cc80ba"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_send_with_reply" ref="ga215df7ab7ca6dce7be153c6b9cc80ba" args="(DBusConnection *connection, DBusMessage *message, DBusPendingCall **pending_return, int timeout_milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_send_with_reply           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> **&nbsp;</td>
          <td class="paramname"> <em>pending_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_milliseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queues a message to send, as with <a class="el" href="group__DBusConnection.html#ge1cb64f4cf550949b23fd3a756b2f7d0">dbus_connection_send()</a>, but also returns a <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> used to receive a reply to the message. 
<p>
If no reply is received in the given timeout_milliseconds, this function expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred.<p>
A <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> will see a reply message before any filters or registered object path handlers. See <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> for details on when handlers are run.<p>
A <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> will always see exactly one reply message, unless it's cancelled with <a class="el" href="group__DBusPendingCall.html#g6530d18f891d3ca5f5df87ea7c2b155c">dbus_pending_call_cancel()</a>.<p>
If <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> is passed for the pending_return, the <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> will still be generated internally, and used to track the message reply timeout. This means a timeout error will occur if no reply arrives, unlike with <a class="el" href="group__DBusConnection.html#ge1cb64f4cf550949b23fd3a756b2f7d0">dbus_connection_send()</a>.<p>
If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If <a class="el" href="group__DBusPendingCall.html#g21384c9c5b0da54f7d0a92012522f213">DBUS_TIMEOUT_INFINITE</a> is passed for the timeout, no timeout will be set and the call will block forever.<p>
<dl compact><dt><b>Warning:</b></dt><dd>if the connection is disconnected or you try to send Unix file descriptors on a connection that does not support them, the <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> will be set to <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, so be careful with this.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the message to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pending_return</em>&nbsp;</td><td>return location for a <a class="el" href="structDBusPendingCall.html">DBusPendingCall</a> object, or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> if connection is disconnected or when you try to send Unix file descriptors on a connection that does not support them. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_milliseconds</em>&nbsp;</td><td>timeout in milliseconds, -1 (or <a class="el" href="group__DBusPendingCall.html#gbdc138a303699e88756d6c5988a16b05">DBUS_TIMEOUT_USE_DEFAULT</a>) for default or <a class="el" href="group__DBusPendingCall.html#g21384c9c5b0da54f7d0a92012522f213">DBUS_TIMEOUT_INFINITE</a> for no timeout </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if no memory, <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> otherwise. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03399">3399</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00109">_dbus_pending_call_new_unlocked()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00354">_dbus_pending_call_set_timeout_error_unlocked()</a>, <a class="el" href="dbus-transport_8c-source.html#l00843">_dbus_transport_can_pass_unix_fd()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-message_8c-source.html#l01150">dbus_message_get_serial()</a>, <a class="el" href="dbus-message_8c-source.html#l00277">dbus_message_set_serial()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00597">dbus_pending_call_unref()</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="dbus-message-private_8h-source.html#l00129">DBusMessage::n_unix_fds</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
<p>
Referenced by <a class="el" href="dbus-connection_8c-source.html#l03535">dbus_connection_send_with_reply_and_block()</a>.
</div>
</div><p>
<a class="anchor" name="g8d6431f17a9e53c9446d87c2ba8409f0"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_send_with_reply_and_block" ref="g8d6431f17a9e53c9446d87c2ba8409f0" args="(DBusConnection *connection, DBusMessage *message, int timeout_milliseconds, DBusError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="structDBusMessage.html">DBusMessage</a> * dbus_connection_send_with_reply_and_block           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_milliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusError.html">DBusError</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message and blocks a certain time period while waiting for a reply. 
<p>
This function does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. This function is used to invoke method calls on a remote object.<p>
If a normal reply is received, it is returned, and removed from the incoming message queue. If it is not received, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> is returned and the error is set to <a class="el" href="group__DBusProtocol.html#gde2cb1c5a6adf47af18672865f233b6d">DBUS_ERROR_NO_REPLY</a>. If an error reply is received, it is converted to a <a class="el" href="structDBusError.html">DBusError</a> and returned as an error, then the reply message is deleted and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> is returned. If something else goes wrong, result is set to whatever is appropriate, such as <a class="el" href="group__DBusProtocol.html#gc32eaf0b92f798307853cd4fe0cf11c2">DBUS_ERROR_NO_MEMORY</a> or <a class="el" href="group__DBusProtocol.html#gef6443e0bd8cdcc1606d985a775d07a7">DBUS_ERROR_DISCONNECTED</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>While this function blocks the calling thread will not be processing the incoming message queue. This means you can end up deadlocked if the application you're talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use <a class="el" href="group__DBusPendingCall.html#g16b67b418b1dc27cfdda6b20f7447670">dbus_pending_call_set_notify()</a> to avoid blocking.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the message to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_milliseconds</em>&nbsp;</td><td>timeout in milliseconds, -1 (or <a class="el" href="group__DBusPendingCall.html#gbdc138a303699e88756d6c5988a16b05">DBUS_TIMEOUT_USE_DEFAULT</a>) for default or <a class="el" href="group__DBusPendingCall.html#g21384c9c5b0da54f7d0a92012522f213">DBUS_TIMEOUT_INFINITE</a> for no timeout </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>return location for error message </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the message that is the reply or <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> with an error code if the function fails. </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03535">3535</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8h-source.html#l00140">_dbus_assert</a>, <a class="el" href="dbus-transport_8c-source.html#l00843">_dbus_transport_can_pass_unix_fd()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l03399">dbus_connection_send_with_reply()</a>, <a class="el" href="dbus-protocol_8h-source.html#l00389">DBUS_ERROR_DISCONNECTED</a>, <a class="el" href="dbus-protocol_8h-source.html#l00355">DBUS_ERROR_FAILED</a>, <a class="el" href="dbus-message_8c-source.html#l01713">dbus_message_unref()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00737">dbus_pending_call_block()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00702">dbus_pending_call_steal_reply()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00597">dbus_pending_call_unref()</a>, <a class="el" href="dbus-errors_8c-source.html#l00354">dbus_set_error()</a>, <a class="el" href="dbus-message_8c-source.html#l03869">dbus_set_error_from_message()</a>, <a class="el" href="dbus-message-private_8h-source.html#l00129">DBusMessage::n_unix_fds</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
<p>
Referenced by <a class="el" href="dbus-bus_8c-source.html#l00948">dbus_bus_get_id()</a>, <a class="el" href="dbus-bus_8c-source.html#l00865">dbus_bus_get_unix_user()</a>, <a class="el" href="dbus-bus_8c-source.html#l01280">dbus_bus_name_has_owner()</a>, <a class="el" href="dbus-bus_8c-source.html#l00646">dbus_bus_register()</a>, <a class="el" href="dbus-bus_8c-source.html#l01198">dbus_bus_release_name()</a>, <a class="el" href="dbus-bus_8c-source.html#l01112">dbus_bus_request_name()</a>, and <a class="el" href="dbus-bus_8c-source.html#l01356">dbus_bus_start_service_by_name()</a>.
</div>
</div><p>
<a class="anchor" name="gde349ff04ed548993a8054250e317c12"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_allow_anonymous" ref="gde349ff04ed548993a8054250e317c12" args="(DBusConnection *connection, dbus_bool_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_allow_anonymous           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function must be called on the server side of a connection when the connection is first seen in the <a class="el" href="group__DBusServer.html#g86c64a45e0834df26a8feae3079f6fbf">DBusNewConnectionFunction</a>. 
<p>
If set to <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> (the default is <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>), then the connection can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously.<p>
This setting interacts with the available authorization mechanisms (see <a class="el" href="group__DBusServer.html#g309e5f1510c74c4b221d12d874d53341">dbus_server_set_auth_mechanisms()</a>). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work.<p>
This setting also changes the default rule for connections authorized as a user; normally, if a connection authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed.<p>
You can override the rules for connections authorized as a user identity with <a class="el" href="group__DBusConnection.html#g6b78379badb4c5804344f4f3d87a958a">dbus_connection_set_unix_user_function()</a> and <a class="el" href="group__DBusConnection.html#ga35ced9ccd29d3366749ae383b120f9c">dbus_connection_set_windows_user_function()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>whether to allow authentication as an anonymous user </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05508">5508</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01536">_dbus_transport_set_allow_anonymous()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g794d0b572e30448fb262618222f76124"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_change_sigpipe" ref="g794d0b572e30448fb262618222f76124" args="(dbus_bool_t will_modify_sigpipe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_change_sigpipe           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>will_modify_sigpipe</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets a global flag for whether dbus_connection_new() will set SIGPIPE behavior to SIG_IGN. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>will_modify_sigpipe</em>&nbsp;</td><td><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> to allow sigpipe to be set to SIG_IGN </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06100">6100</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>.
</div>
</div><p>
<a class="anchor" name="g845b4942399f43dd4ac644de7cb9e3ff"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_data" ref="g845b4942399f43dd4ac644de7cb9e3ff" args="(DBusConnection *connection, dbus_int32_t slot, void *data, DBusFreeFunction free_data_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_set_data           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#gb18afa60e9b17b6e322735bda3d863d8">dbus_int32_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores a pointer on a <a class="el" href="structDBusConnection.html">DBusConnection</a>, along with an optional function to be used for freeing the data when the data is set again, or when the connection is finalized. 
<p>
The slot number must have been allocated with <a class="el" href="group__DBusConnection.html#g728b15c71a492ad244e5a480f1156088">dbus_connection_allocate_data_slot()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>This function does not take the main thread lock on <a class="el" href="structDBusConnection.html">DBusConnection</a>, which allows it to be used from inside watch and timeout functions. (See the note in docs for <a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions()</a>.) A side effect of this is that you need to know there's a reference held on the connection while invoking <a class="el" href="group__DBusConnection.html#g845b4942399f43dd4ac644de7cb9e3ff">dbus_connection_set_data()</a>, or the connection could be finalized during <a class="el" href="group__DBusConnection.html#g845b4942399f43dd4ac644de7cb9e3ff">dbus_connection_set_data()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>the slot number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the data to store </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_func</em>&nbsp;</td><td>finalizer function for the data </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if there was enough memory to store the data </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06025">6025</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-dataslot_8c-source.html#l00221">_dbus_data_slot_list_set()</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00287">slot_list</a>.
</div>
</div><p>
<a class="anchor" name="g55ff88cd22c0672441c7deffbfb68fbf"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_dispatch_status_function" ref="g55ff88cd22c0672441c7deffbfb68fbf" args="(DBusConnection *connection, DBusDispatchStatusFunction function, void *data, DBusFreeFunction free_data_function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_dispatch_status_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#gd888331dd2737769f669c5df779fe0ef">DBusDispatchStatusFunction</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a function to be invoked when the dispatch status changes. 
<p>
If the dispatch status is <a class="el" href="group__DBusConnection.html#ggbf250a32ff740b2a8c99136e0142d8d2df8e8a594ab338cb9cf7855b19e37e93">DBUS_DISPATCH_DATA_REMAINS</a>, then <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> needs to be called to process incoming messages. However, <a class="el" href="group__DBusConnection.html#g66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch()</a> MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in this function is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered.<p>
If you don't set a dispatch status function, you have to be sure to dispatch on every iteration of your main loop, especially if <a class="el" href="group__DBusWatch.html#gc2acdb1794450ac01a43ec4c3e07ebf7">dbus_watch_handle()</a> or <a class="el" href="group__DBusTimeout.html#g038b67c8d3db2624a1e4a8bc45f25d12">dbus_timeout_handle()</a> were called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>function to call on dispatch status changes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>data for function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_function</em>&nbsp;</td><td>free the function data </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05099">5099</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l00299">dispatch_status_data</a>, <a class="el" href="dbus-connection_8c-source.html#l00298">dispatch_status_function</a>, <a class="el" href="dbus-connection_8c-source.html#l00300">free_dispatch_status_data</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g19091beb74f1504b0e862a7ad10e71cd"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_exit_on_disconnect" ref="g19091beb74f1504b0e862a7ad10e71cd" args="(DBusConnection *connection, dbus_bool_t exit_on_disconnect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_exit_on_disconnect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>exit_on_disconnect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether _exit() should be called when the connection receives a disconnect signal. 
<p>
The call to _exit() comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function.<p>
By default, exit_on_disconnect is <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>; but for message bus connections returned from <a class="el" href="group__DBusBus.html#g77ba5250adb84620f16007e1b023cf26">dbus_bus_get()</a> it will be toggled on by default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exit_on_disconnect</em>&nbsp;</td><td><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> if _exit() should be called after a disconnect signal </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03145">3145</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l00317">exit_on_disconnect</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g0d783462274a6c71d3767f5821c29ce9"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_max_message_size" ref="g0d783462274a6c71d3767f5821c29ce9" args="(DBusConnection *connection, long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_max_message_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies the maximum size message this connection is allowed to receive. 
<p>
Larger messages will result in disconnecting the connection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>a <a class="el" href="structDBusConnection.html">DBusConnection</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>maximum message size the connection can receive, in bytes </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06114">6114</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01199">_dbus_transport_set_max_message_size()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g2aadce7d15c0e11983363912292b3fcd"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_max_message_unix_fds" ref="g2aadce7d15c0e11983363912292b3fcd" args="(DBusConnection *connection, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_max_message_unix_fds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies the maximum number of unix fds a message on this connection is allowed to receive. 
<p>
Messages with more unix fds will result in disconnecting the connection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>a <a class="el" href="structDBusConnection.html">DBusConnection</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>maximum message unix fds the connection can receive </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06153">6153</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01212">_dbus_transport_set_max_message_unix_fds()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g6565d75f16e6e803372b2ae3d94d991b"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_max_received_size" ref="g6565d75f16e6e803372b2ae3d94d991b" args="(DBusConnection *connection, long size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_max_received_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum total number of bytes that can be used for all messages received on this connection. 
<p>
Messages count toward the maximum until they are finalized. When the maximum is reached, the connection will not read more data until some messages are finalized.<p>
The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we don't read it. The reason is that we don't know the size of a message until after we read it.<p>
Thus, the max live messages size can actually be exceeded by up to the maximum size of a single message.<p>
Also, if we read say 1024 bytes off the wire in a single read(), and that contains a half-dozen small messages, we may exceed the size max by that amount. But this should be inconsequential.<p>
This does imply that we can't call read() with a buffer larger than we're willing to exceed this limit by.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the maximum size in bytes of all outstanding messages </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06209">6209</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01249">_dbus_transport_set_max_received_size()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g81e63dc6d9298e8a7f92c0d93d0e80b3"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_max_received_unix_fds" ref="g81e63dc6d9298e8a7f92c0d93d0e80b3" args="(DBusConnection *connection, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_max_received_unix_fds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum total number of unix fds that can be used for all messages received on this connection. 
<p>
Messages count toward the maximum until they are finalized. When the maximum is reached, the connection will not read more data until some messages are finalized.<p>
The semantics are analogous to those of <a class="el" href="group__DBusConnection.html#g6565d75f16e6e803372b2ae3d94d991b">dbus_connection_set_max_received_size()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>the maximum size in bytes of all outstanding messages </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l06251">6251</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01267">_dbus_transport_set_max_received_unix_fds()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="gf58e8cc7b8717db1581459c0c3d34b08"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_route_peer_messages" ref="gf58e8cc7b8717db1581459c0c3d34b08" args="(DBusConnection *connection, dbus_bool_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_route_peer_messages           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normally <a class="el" href="structDBusConnection.html">DBusConnection</a> automatically handles all messages to the org.freedesktop.DBus.Peer interface. 
<p>
However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the <a class="el" href="structDBusConnection.html">DBusConnection</a> and instead will be dispatched normally to the application.<p>
If a normal application sets this flag, it can break things badly. So don't set this unless you are the message bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td><a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> to pass through org.freedesktop.DBus.Peer messages with a bus name set </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05536">5536</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00319">route_peer_messages</a>.
</div>
</div><p>
<a class="anchor" name="gb3cbc68eec427e9ce1783b25d44fe93c"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_timeout_functions" ref="gb3cbc68eec427e9ce1783b25d44fe93c" args="(DBusConnection *connection, DBusAddTimeoutFunction add_function, DBusRemoveTimeoutFunction remove_function, DBusTimeoutToggledFunction toggled_function, void *data, DBusFreeFunction free_data_function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_set_timeout_functions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g0f4e9f850546dfbe3a27edea05e5e590">DBusAddTimeoutFunction</a>&nbsp;</td>
          <td class="paramname"> <em>add_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#gb11e8c56bd8637deca1439be635f6ca7">DBusRemoveTimeoutFunction</a>&nbsp;</td>
          <td class="paramname"> <em>remove_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g1e98eb88ce848204d419495be5e1d228">DBusTimeoutToggledFunction</a>&nbsp;</td>
          <td class="paramname"> <em>toggled_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the timeout functions for the connection. 
<p>
These functions are responsible for making the application's main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add.<p>
The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call <a class="el" href="group__DBusTimeout.html#g58954b2edb45ec1632529d35525ea45c">dbus_timeout_get_enabled()</a> to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start() and QTimer::stop() can be used to enable and disable. The toggled function may be NULL if a main loop re-queries <a class="el" href="group__DBusTimeout.html#g58954b2edb45ec1632529d35525ea45c">dbus_timeout_get_enabled()</a> every time anyway. Whenever a timeout is toggled, its interval may change.<p>
The <a class="el" href="structDBusTimeout.html">DBusTimeout</a> can be queried for the timer interval using <a class="el" href="group__DBusTimeout.html#g67ba21b6189438875c6007ee79da5e37">dbus_timeout_get_interval()</a>. <a class="el" href="group__DBusTimeout.html#g038b67c8d3db2624a1e4a8bc45f25d12">dbus_timeout_handle()</a> should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given remove_function. The timer interval may change whenever the timeout is added, removed, or toggled.<p>
<dl compact><dt><b>Note:</b></dt><dd>The thread lock on <a class="el" href="structDBusConnection.html">DBusConnection</a> is held while timeout functions are invoked, so inside these functions you may not invoke any methods on <a class="el" href="structDBusConnection.html">DBusConnection</a> or it will deadlock. See the comments in the code or <a href="http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144">http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144</a> if you encounter this issue and want to attempt writing a patch.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add_function</em>&nbsp;</td><td>function to add a timeout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remove_function</em>&nbsp;</td><td>function to remove a timeout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toggled_function</em>&nbsp;</td><td>function to notify of enable/disable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>data to pass to add_function and remove_function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_function</em>&nbsp;</td><td>function to be called to free the data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> on failure (no memory) </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05015">5015</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-timeout_8c-source.html#l00239">_dbus_timeout_list_set_functions()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00282">timeouts</a>.
</div>
</div><p>
<a class="anchor" name="g6b78379badb4c5804344f4f3d87a958a"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_unix_user_function" ref="g6b78379badb4c5804344f4f3d87a958a" args="(DBusConnection *connection, DBusAllowUnixUserFunction function, void *data, DBusFreeFunction free_data_function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_unix_user_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g141b80629859a4c154c793f08c33d687">DBusAllowUnixUserFunction</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a predicate function used to determine whether a given user ID is allowed to connect. 
<p>
When an incoming connection has authenticated with a particular user ID, this function is called; if it returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, the connection is allowed to proceed, otherwise the connection is disconnected.<p>
If the function is set to <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect.<p>
On Windows, the function will be set and its free_data_function will be invoked when the connection is freed or a new function is set. However, the function will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>data to pass to the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_function</em>&nbsp;</td><td>function to free the data </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05336">5336</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01413">_dbus_transport_set_unix_user_function()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g2b1df13251c7ec348bcba39c0924e881"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_wakeup_main_function" ref="g2b1df13251c7ec348bcba39c0924e881" args="(DBusConnection *connection, DBusWakeupMainFunction wakeup_main_function, void *data, DBusFreeFunction free_data_function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_wakeup_main_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g8d21e6bab0bbca3efd2c6d5acb53d468">DBusWakeupMainFunction</a>&nbsp;</td>
          <td class="paramname"> <em>wakeup_main_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mainloop wakeup function for the connection. 
<p>
This function is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the connection that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp(). When using GLib, it would call g_main_context_wakeup().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wakeup_main_function</em>&nbsp;</td><td>function to wake up the mainloop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>data to pass wakeup_main_function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_function</em>&nbsp;</td><td>function to be called to free the data. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05053">5053</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l00296">free_wakeup_main_data</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00295">wakeup_main_data</a>, and <a class="el" href="dbus-connection_8c-source.html#l00294">wakeup_main_function</a>.
</div>
</div><p>
<a class="anchor" name="gebf031eb444b4f847606aa27daa3d8e6"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_watch_functions" ref="gebf031eb444b4f847606aa27daa3d8e6" args="(DBusConnection *connection, DBusAddWatchFunction add_function, DBusRemoveWatchFunction remove_function, DBusWatchToggledFunction toggled_function, void *data, DBusFreeFunction free_data_function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_set_watch_functions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g985b712fc165afa66e5901859b68b9de">DBusAddWatchFunction</a>&nbsp;</td>
          <td class="paramname"> <em>add_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#g6a48c42c4bde24911cae7fda0d1f1589">DBusRemoveWatchFunction</a>&nbsp;</td>
          <td class="paramname"> <em>remove_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#gfa7e0f7856f8ebbe66475979ef54ed9e">DBusWatchToggledFunction</a>&nbsp;</td>
          <td class="paramname"> <em>toggled_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the watch functions for the connection. 
<p>
These functions are responsible for making the application's main loop aware of file descriptors that need to be monitored for events, using select() or poll(). When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch(), or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled.<p>
The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call <a class="el" href="group__DBusWatch.html#ge7a91e6d4d1bc187419c47c522e33a8f">dbus_watch_get_enabled()</a> to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries <a class="el" href="group__DBusWatch.html#ge7a91e6d4d1bc187419c47c522e33a8f">dbus_watch_get_enabled()</a> every time anyway.<p>
The <a class="el" href="structDBusWatch.html">DBusWatch</a> can be queried for the file descriptor to watch using <a class="el" href="group__DBusWatch.html#g15df7f6120ead3e09bec8a70d3c43c0d">dbus_watch_get_unix_fd()</a> or <a class="el" href="group__DBusWatch.html#g91308f393d41b31babda17c83833517f">dbus_watch_get_socket()</a>, and for the events to watch for using <a class="el" href="group__DBusWatch.html#gf172a2b1d1f82333e67cec8d99c9204a">dbus_watch_get_flags()</a>. The flags returned by <a class="el" href="group__DBusWatch.html#gf172a2b1d1f82333e67cec8d99c9204a">dbus_watch_get_flags()</a> will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions.<p>
Once a file descriptor becomes readable or writable, or an exception occurs, <a class="el" href="group__DBusWatch.html#gc2acdb1794450ac01a43ec4c3e07ebf7">dbus_watch_handle()</a> should be called to notify the connection of the file descriptor's condition.<p>
<a class="el" href="group__DBusWatch.html#gc2acdb1794450ac01a43ec4c3e07ebf7">dbus_watch_handle()</a> cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that watch yet.<p>
It is not allowed to reference a <a class="el" href="structDBusWatch.html">DBusWatch</a> after it has been passed to remove_function.<p>
If <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> is returned due to lack of memory, the failure may be due to a <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> return from the new add_function. If so, the add_function may have been called successfully one or more times, but the remove_function will also have been called to remove any successful adds. i.e. if <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> is returned the net result should be that <a class="el" href="group__DBusConnection.html#gebf031eb444b4f847606aa27daa3d8e6">dbus_connection_set_watch_functions()</a> has no effect, but the add_function and remove_function may have been called.<p>
<dl compact><dt><b>Note:</b></dt><dd>The thread lock on <a class="el" href="structDBusConnection.html">DBusConnection</a> is held while watch functions are invoked, so inside these functions you may not invoke any methods on <a class="el" href="structDBusConnection.html">DBusConnection</a> or it will deadlock. See the comments in the code or <a href="http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144">http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144</a> if you encounter this issue and want to attempt writing a patch.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add_function</em>&nbsp;</td><td>function to begin monitoring a new descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remove_function</em>&nbsp;</td><td>function to stop monitoring a descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toggled_function</em>&nbsp;</td><td>function to notify of enable/disable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>data to pass to add_function and remove_function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_function</em>&nbsp;</td><td>function to be called to free the data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> on failure (no memory) </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l04952">4952</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-watch_8c-source.html#l00296">_dbus_watch_list_set_functions()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00281">watches</a>.
</div>
</div><p>
<a class="anchor" name="ga35ced9ccd29d3366749ae383b120f9c"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_set_windows_user_function" ref="ga35ced9ccd29d3366749ae383b120f9c" args="(DBusConnection *connection, DBusAllowWindowsUserFunction function, void *data, DBusFreeFunction free_data_function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_set_windows_user_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusConnection.html#gf5c1e751b33a480c33f9141ad3ac75d9">DBusAllowWindowsUserFunction</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DBusMemory.html#g8792ec2b2b8626ca28022faf51ec415a">DBusFreeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>free_data_function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a predicate function used to determine whether a given user ID is allowed to connect. 
<p>
When an incoming connection has authenticated with a particular user ID, this function is called; if it returns <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, the connection is allowed to proceed, otherwise the connection is disconnected.<p>
If the function is set to <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> (as it is by default), then only the same user owning the server process will be allowed to connect.<p>
On UNIX, the function will be set and its free_data_function will be invoked when the connection is freed or a new function is set. However, the function will never be called, because there is no way right now to authenticate as a Windows user on UNIX.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>data to pass to the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_data_function</em>&nbsp;</td><td>function to free the data </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05461">5461</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-transport_8c-source.html#l01499">_dbus_transport_set_windows_user_function()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00057">CONNECTION_UNLOCK</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
</div>
</div><p>
<a class="anchor" name="g7125d747575b2f596aceaf7be53eae68"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_steal_borrowed_message" ref="g7125d747575b2f596aceaf7be53eae68" args="(DBusConnection *connection, DBusMessage *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_steal_borrowed_message           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusMessage.html">DBusMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to keep a message after peeking at it using <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a>. 
<p>
Before using this function, see the caveats/warnings in the documentation for <a class="el" href="group__DBusConnection.html#g1e40d994ea162ce767e78de1c4988566">dbus_connection_pop_message()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the message from <a class="el" href="group__DBusConnection.html#g9d07083c520e291591a68adb78f64094">dbus_connection_borrow_message()</a> </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l03935">3935</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-internals_8h-source.html#l00140">_dbus_assert</a>, <a class="el" href="dbus-list_8c-source.html#l00649">_dbus_list_pop_first()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-connection_8c-source.html#l00312">dispatch_acquired</a>, <a class="el" href="dbus-connection_8c-source.html#l00268">incoming_messages</a>, <a class="el" href="dbus-connection_8c-source.html#l00271">message_borrowed</a>, <a class="el" href="dbus-connection_8c-source.html#l00276">n_incoming</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g8e9d2d4ff17c3071124e4993d1536ed4"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_try_register_fallback" ref="g8e9d2d4ff17c3071124e4993d1536ed4" args="(DBusConnection *connection, const char *path, const DBusObjectPathVTable *vtable, void *user_data, DBusError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_try_register_fallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *&nbsp;</td>
          <td class="paramname"> <em>vtable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusError.html">DBusError</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a fallback handler for a given subsection of the object hierarchy. 
<p>
The given vtable handles messages at or below the given path. You can use this to establish a default message handling policy for a whole "subdirectory."<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>a '/' delimited string of path elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtable</em>&nbsp;</td><td>the virtual table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>data to pass to functions in the vtable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>address where an error can be returned </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if an error (<a class="el" href="group__DBusProtocol.html#gc32eaf0b92f798307853cd4fe0cf11c2">DBUS_ERROR_NO_MEMORY</a> or <a class="el" href="group__DBusProtocol.html#g6a4358a62f0cd68d637532772475e576">DBUS_ERROR_OBJECT_PATH_IN_USE</a>) is reported </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05799">5799</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
</div>
</div><p>
<a class="anchor" name="g708b1e108feed18f5775ff404c9dda4b"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_try_register_object_path" ref="g708b1e108feed18f5775ff404c9dda4b" args="(DBusConnection *connection, const char *path, const DBusObjectPathVTable *vtable, void *user_data, DBusError *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_try_register_object_path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDBusObjectPathVTable.html">DBusObjectPathVTable</a> *&nbsp;</td>
          <td class="paramname"> <em>vtable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDBusError.html">DBusError</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a handler for a given path in the object hierarchy. 
<p>
The given vtable handles messages sent to exactly the given path.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>a '/' delimited string of path elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtable</em>&nbsp;</td><td>the virtual table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>data to pass to functions in the vtable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>address where an error can be returned </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if an error (<a class="el" href="group__DBusProtocol.html#gc32eaf0b92f798307853cd4fe0cf11c2">DBUS_ERROR_NO_MEMORY</a> or <a class="el" href="group__DBusProtocol.html#g6a4358a62f0cd68d637532772475e576">DBUS_ERROR_OBJECT_PATH_IN_USE</a>) is reported </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05729">5729</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, and <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.
</div>
</div><p>
<a class="anchor" name="g6385ff09bc108238c4429e7c195dab25"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_unref" ref="g6385ff09bc108238c4429e7c195dab25" args="(DBusConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT void dbus_connection_unref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrements the reference count of a <a class="el" href="structDBusConnection.html">DBusConnection</a>, and finalizes it if the count reaches zero. 
<p>
Note: it is a bug to drop the last reference to a connection that is still connected.<p>
For shared connections, libdbus will own a reference as long as the connection is connected, so you can know that either you don't have the last reference, or it's OK to drop the last reference. Most connections are shared. <a class="el" href="group__DBusConnection.html#gcd32f819820266598c6b6847dfddaf9c">dbus_connection_open()</a> and <a class="el" href="group__DBusBus.html#g77ba5250adb84620f16007e1b023cf26">dbus_bus_get()</a> return shared connections.<p>
For private connections, the creator of the connection must arrange for <a class="el" href="group__DBusConnection.html#g2522ac5075dfe0a1535471f6e045e1ee">dbus_connection_close()</a> to be called prior to dropping the last reference. Private connections come from <a class="el" href="group__DBusConnection.html#g434e3fc7ee420fd30e2f05e57ff26b1d">dbus_connection_open_private()</a> or <a class="el" href="group__DBusBus.html#g9c62186f19cf3bd3c7c604bdcefb4e09">dbus_bus_get_private()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l02817">2817</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-sysdeps-unix_8c-source.html#l02776">_dbus_atomic_dec()</a>, <a class="el" href="dbus-memory_8c-source.html#l00781">_dbus_current_generation</a>, <a class="el" href="dbus-transport_8c-source.html#l00527">_dbus_transport_get_is_connected()</a>, <a class="el" href="dbus-internals_8c-source.html#l00258">_dbus_warn_check_failed()</a>, <a class="el" href="dbus-connection_8c-source.html#l00334">generation</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00258">refcount</a>, <a class="el" href="dbus-connection_8c-source.html#l00315">shareable</a>, and <a class="el" href="dbus-connection_8c-source.html#l00280">transport</a>.
<p>
Referenced by <a class="el" href="dbus-object-tree_8c-source.html#l00625">_dbus_object_tree_unregister_and_unlock()</a>, and <a class="el" href="dbus-connection_8c-source.html#l04575">dbus_connection_dispatch()</a>.
</div>
</div><p>
<a class="anchor" name="g6ae8f005dedf24c5f2df1768795392fb"></a><!-- doxytag: member="dbus-connection.c::dbus_connection_unregister_object_path" ref="g6ae8f005dedf24c5f2df1768795392fb" args="(DBusConnection *connection, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBUS_EXPORT <a class="el" href="group__DBusTypes.html#g39c9cb0f3a2a8ad6f55cc4855d035349">dbus_bool_t</a> dbus_connection_unregister_object_path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDBusConnection.html">DBusConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters the handler registered with exactly the given path. 
<p>
It's a bug to call this function for a path that isn't registered. Can unregister both fallback paths and object paths.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>a '/' delimited string of path elements </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a> if not enough memory </dd></dl>

<p>
Definition at line <a class="el" href="dbus-connection_8c-source.html#l05866">5866</a> of file <a class="el" href="dbus-connection_8c-source.html">dbus-connection.c</a>.
<p>
References <a class="el" href="dbus-object-tree_8c-source.html#l01244">_dbus_decompose_path()</a>, <a class="el" href="dbus-object-tree_8c-source.html#l00625">_dbus_object_tree_unregister_and_unlock()</a>, <a class="el" href="dbus-pending-call_8c-source.html#l00053">CONNECTION_LOCK</a>, <a class="el" href="dbus-memory_8c-source.html#l00749">dbus_free_string_array()</a>, <a class="el" href="group__DBusMacros.html#ga93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="group__DBusMacros.html#g070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="dbus-connection_8c-source.html#l00304">objects</a>, and <a class="el" href="group__DBusMacros.html#ga8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on 13 Sep 2016 for D-Bus by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
